/*!
 * RasterMapProjection v0.0.27  2019-02-10
 *   https://github.com/tomosn/raster-map-projection
 *   A JavaScript library for on-the-fly map projection of raster tiles using WebGL.
 * Copyright (C) 2016-2019 T.Seno
 * All rights reserved. 
 * @license GPL v3 License (http://www.gnu.org/licenses/gpl.html)
 */

"use strict";if("undefined"!=typeof module&&module.exports)var ProjMath=require("./rasterproj-common.js");function ProjDiscreteMath(t){this.divN_=t,this.unit_=2/t}function ProjLAEA(t,o,e){this.lam0=t,this.phi0=o,this.divN_=void 0!==e?e:180,this.dMath_=new ProjDiscreteMath(this.divN_),this.sin_phi0_=Math.sin(o),this.cos_phi0_=Math.cos(o)}RasterMapProjection.createProjection=function(t,o,e){return new ProjLAEA(t,o,e)},ProjDiscreteMath.prototype.toDiscrete=function(t){return Math.floor(t/this.unit_)},ProjDiscreteMath.prototype.cosR_lower=function(t,o){const e=0<=t?(t+1)*this.unit_:-t*this.unit_,r=Math.sqrt(e*e+o*o);return r<=2?Math.cos(2*Math.asin(r/2)):-1},ProjDiscreteMath.prototype.cosR_upper=function(t,o){const e=0<=t?t*this.unit_:(-t-1)*this.unit_,r=Math.sqrt(e*e+o*o);return r<=2?Math.cos(2*Math.asin(r/2)):-1},ProjDiscreteMath.prototype.sinR_lower=function(t,o){const e=t*this.unit_,r=(t+1)*this.unit_,i=Math.sqrt(e*e+o*o),a=Math.sqrt(r*r+o*o);if(2<=i||2<=a)return 0;if(i<=ProjMath.SQRT_2&&a<=ProjMath.SQRT_2){const t=Math.min(i,a);return Math.sin(2*Math.asin(t/2))}if(ProjMath.SQRT_2<=i&&ProjMath.SQRT_2<=a){const t=Math.max(i,a);return Math.sin(2*Math.asin(t/2))}const n=Math.sin(2*Math.asin(i/2)),s=Math.sin(2*Math.asin(a/2));return n<s?n:s},ProjDiscreteMath.prototype.sinR_upper=function(t,o){const e=t*this.unit_,r=(t+1)*this.unit_,i=Math.sqrt(e*e+o*o),a=Math.sqrt(r*r+o*o);if(2<=i&&2<=a)return 0;if(i<=ProjMath.SQRT_2&&a<=ProjMath.SQRT_2){const t=Math.max(i,a);return Math.sin(2*Math.asin(t/2))}if(ProjMath.HALF_PI<=i&&ProjMath.HALF_PI<=a){const t=Math.min(i,a);return Math.sin(2*Math.asin(t/2))}return 1},ProjDiscreteMath.prototype.R_cotR_lower=function(t,o){const e=0<=t?(t+1)*this.unit_:-t*this.unit_,r=Math.sqrt(e*e+o*o);return r<ProjMath.EPSILON?1:r<2?r/Math.tan(2*Math.asin(r/2)):-1/0},ProjDiscreteMath.prototype.R_cotR_upper=function(t,o){const e=0<=t?t*this.unit_:(-t-1)*this.unit_,r=Math.sqrt(e*e+o*o);return r<ProjMath.EPSILON?1:r<2?r/Math.tan(2*Math.asin(r/2)):-1/0},ProjDiscreteMath.prototype.sinR_divR_lower=function(t,o){const e=0<=t?(t+1)*this.unit_:-t*this.unit_,r=Math.sqrt(e*e+o*o);return r<ProjMath.EPSILON?1:r<2?Math.sin(2*Math.asin(r/2))/r:0},ProjDiscreteMath.prototype.sinR_divR_upper=function(t,o){const e=0<=t?t*this.unit_:(-t-1)*this.unit_,r=Math.sqrt(e*e+o*o);return r<ProjMath.EPSILON?1:r<2?Math.sin(2*Math.asin(r/2))/r:0},ProjDiscreteMath.prototype.X_lower=function(t){return t*this.unit_},ProjDiscreteMath.prototype.X_upper=function(t){return(t+1)*this.unit_},ProjLAEA.RANGE_RECTANGLE=[-2,-2,2,2],ProjLAEA.prototype.getRange=function(){return ProjLAEA.RANGE_RECTANGLE.slice(0)},ProjLAEA.prototype.getProjCenter=function(){return{lambda:this.lam0,phi:this.phi0}},ProjLAEA.prototype.setProjCenter=function(t,o){this.lam0=t,this.phi0=o,this.sin_phi0_=Math.sin(o),this.cos_phi0_=Math.cos(o)},ProjLAEA.prototype.checkXYDomain=function(t,o,e){let r=2;if(null!=e&&(r*=e),Math.abs(t)<r&&Math.abs(o)<r)return!0;return t*t+o*o<r*r},ProjLAEA.prototype.forward=function(t,o){const e=Math.sin(o),r=Math.cos(o),i=Math.sin(t-this.lam0),a=Math.cos(t-this.lam0),n=1+this.sin_phi0_*e+this.cos_phi0_*r*a;if(Math.abs(n)<ProjMath.EPSILON)return null;const s=Math.sqrt(2/n);return{x:s*r*i,y:s*(this.cos_phi0_*e-this.sin_phi0_*r*a)}},ProjLAEA.prototype.inverse=function(t,o){const e=t*t+o*o;if(4<e)return null;const r=Math.sqrt(e);if(r<ProjMath.EPSILON)return{lambda:this.lam0,phi:this.phi0};const i=2*Math.asin(ProjMath.clamp(r/2,-1,1)),a=Math.sin(i),n=Math.cos(i),s=n*this.sin_phi0_+o*a*this.cos_phi0_/r,h=Math.asin(ProjMath.clamp(s,-1,1));let c;return((c=ProjMath.HALF_PI-ProjMath.EPSILON<this.phi0?Math.atan2(t,-o)+this.lam0:this.phi0<-(ProjMath.HALF_PI-ProjMath.EPSILON)?Math.atan2(t,o)+this.lam0:Math.atan2(t*a,r*n*this.cos_phi0_-o*this.sin_phi0_*a)+this.lam0)<-Math.PI||Math.PI<=c)&&(c-=2*Math.PI*Math.floor((c+Math.PI)/(2*Math.PI))),{lambda:c,phi:h}},ProjLAEA.prototype.inverseBoundingBox=function(t,o,e,r){const i=t<=e?t:e,a=t<=e?e:t,n=o<=r?o:r,s=o<=r?r:o;if(i<=0&&0<=a){const t=ProjMath.SQRT_2*this.cos_phi0_/Math.sqrt(1+this.sin_phi0_),o=-(ProjMath.HALF_PI-ProjMath.EPSILON)<this.phi0&&n<=t&&t<=s,e=-ProjMath.SQRT_2*this.cos_phi0_/Math.sqrt(1-this.sin_phi0_),r=this.phi0<ProjMath.HALF_PI-ProjMath.EPSILON&&n<=e&&e<=s;if(o&&r)return{lambda:[-Math.PI,+Math.PI],phi:[-Math.PI/2,+Math.PI/2]};if(o||r){const t=this.inversePhiRange_([i,a],[n,s]);return o?{lambda:[-Math.PI,+Math.PI],phi:[t[0],Math.PI/2]}:{lambda:[-Math.PI,+Math.PI],phi:[-Math.PI/2,t[1]]}}if(s<e||t<n){const t=this.inverseLambdaRangeAtY_([i,-ProjMath.EPSILON],[n,s]),o=this.inverseLambdaRangeAtX_([n,s],[i]),e=this.inverseLambdaRangeAtY_([ProjMath.EPSILON,a],[n,s]),r=this.inverseLambdaRangeAtX_([n,s],[a]),h=this.mergeRange_(t,o);let c=[this.mergeRange_(e,r)[0],h[1]+2*Math.PI];const u=this.inversePhiRange_([i,a],[n,s]);return{lambda:c=this.normalizeLambdaRange_(c),phi:u}}}const h=this.inversePhiRange_([i,a],[n,s]);let c=this.inverseLambdaRange_([i,a],[n,s]);return{lambda:c=this.normalizeLambdaRange_(c),phi:h}},ProjLAEA.prototype.mergeRange_=function(t,o){let e=null;return null==t?e=o:null!=o&&(e=t,o[0]<e[0]&&(e[0]=o[0]),e[1]<o[1]&&(e[1]=o[1])),e},ProjLAEA.prototype.normalizeLambdaRange_=function(t){const o=t[0];if(-Math.PI<=o&&o<Math.PI)return t;const e=2*Math.PI*Math.floor((o+Math.PI)/(2*Math.PI));return[t[0]-e,t[1]-e]},ProjLAEA.prototype.inverseLambdaRange_=function(t,o){const e=t[0]<=t[1]?t[0]:t[1],r=t[0]<=t[1]?t[1]:t[0],i=o[0]<=o[1]?o[0]:o[1],a=o[0]<=o[1]?o[1]:o[0],n=this.inverseLambdaRangeAtY_([e,r],[i,a]),s=this.inverseLambdaRangeAtX_([i,a],[e,r]);return this.mergeRange_(s,n)},ProjLAEA.prototype.inverseLambdaRangeAtY_=function(t,o){const e=t[0]<=t[1]?t[0]:t[1],r=t[0]<=t[1]?t[1]:t[0];let i=null;const a=this.dMath_.toDiscrete(e),n=this.dMath_.toDiscrete(r),s=o.length;for(let t=a;t<=n;++t)for(let e=0;e<s;++e){const r=this.inverseLambdaAtY_(t,o[e]);i=this.mergeRange_(i,r)}return i},ProjLAEA.prototype.inverseLambdaRangeAtX_=function(t,o){const e=t[0]<=t[1]?t[0]:t[1],r=t[0]<=t[1]?t[1]:t[0];let i=null;const a=this.dMath_.toDiscrete(e),n=this.dMath_.toDiscrete(r),s=o.length;for(let t=a;t<=n;++t)for(let e=0;e<s;++e){const r=this.inverseLambdaAtX_(t,o[e]);i=this.mergeRange_(i,r)}return i},ProjLAEA.prototype.inversePhiRange_=function(t,o){const e=t[0]<=t[1]?t[0]:t[1],r=t[0]<=t[1]?t[1]:t[0],i=o[0]<=o[1]?o[0]:o[1],a=o[0]<=o[1]?o[1]:o[0],n=this.inversePhiRangeAtY_([e,r],[i,a]),s=this.inversePhiRangeAtX_([i,a],[e,r]);return this.mergeRange_(s,n)},ProjLAEA.prototype.inversePhiRangeAtY_=function(t,o){const e=t[0]<=t[1]?t[0]:t[1],r=t[0]<=t[1]?t[1]:t[0];let i=null;const a=this.dMath_.toDiscrete(e),n=this.dMath_.toDiscrete(r),s=o.length;for(let t=a;t<=n;++t)for(let e=0;e<s;++e){const r=this.inversePhiAtY_(t,o[e]);i=this.mergeRange_(i,r)}return i},ProjLAEA.prototype.inversePhiRangeAtX_=function(t,o){const e=t[0]<=t[1]?t[0]:t[1],r=t[0]<=t[1]?t[1]:t[0];let i=null;const a=this.dMath_.toDiscrete(e),n=this.dMath_.toDiscrete(r),s=o.length;for(let t=a;t<=n;++t)for(let e=0;e<s;++e){const r=this.inversePhiAtX_(t,o[e]);i=this.mergeRange_(i,r)}return i},ProjLAEA.prototype.inverseLambdaAtX_=function(t,o){if(ProjMath.HALF_PI-ProjMath.EPSILON<Math.abs(this.phi0)){const e=0<this.phi0?-1:1,r=e*this.dMath_.X_lower(t),i=e*this.dMath_.X_upper(t),a=r<=i?i:r,n=r<=i?r:i,s=ProjMath.atan2Range({min:o,max:o},{min:n,max:a});return[s.min+this.lam0,s.max+this.lam0]}const e=this.cos_phi0_*this.dMath_.R_cotR_lower(t,o),r=this.cos_phi0_*this.dMath_.R_cotR_upper(t,o),i=e<=r?r:e,a=e<=r?e:r,n=-this.sin_phi0_*this.dMath_.X_lower(t),s=-this.sin_phi0_*this.dMath_.X_upper(t),h=i+(n<=s?s:n),c=a+(n<=s?n:s),u=ProjMath.atan2Range({min:o,max:o},{min:c,max:h});return[u.min+this.lam0,u.max+this.lam0]},ProjLAEA.prototype.inverseLambdaAtY_=function(t,o){if(ProjMath.HALF_PI-ProjMath.EPSILON<Math.abs(this.phi0)){const e=0<this.phi0?-1:1,r=this.dMath_.X_lower(t),i=this.dMath_.X_upper(t),a=ProjMath.atan2Range({min:r,max:i},{min:e*o,max:e*o});return[a.min+this.lam0,a.max+this.lam0]}const e=this.cos_phi0_*this.dMath_.R_cotR_lower(t,o)-this.sin_phi0_*o,r=this.cos_phi0_*this.dMath_.R_cotR_upper(t,o)-this.sin_phi0_*o,i=r<=e?e:r,a=r<=e?r:e,n=this.dMath_.X_lower(t),s=this.dMath_.X_upper(t),h=ProjMath.atan2Range({min:n,max:s},{min:a,max:i});return[h.min+this.lam0,h.max+this.lam0]},ProjLAEA.prototype.inversePhiAtY_=function(t,o){const e=this.dMath_.cosR_lower(t,o)*this.sin_phi0_,r=this.dMath_.cosR_upper(t,o)*this.sin_phi0_,i=e<=r?r:e,a=e<=r?e:r,n=o*this.dMath_.sinR_divR_lower(t,o)*this.cos_phi0_,s=o*this.dMath_.sinR_divR_upper(t,o)*this.cos_phi0_,h=n<=s?s:n,c=n<=s?n:s,u=ProjMath.clamp(i+h,-1,1),_=ProjMath.clamp(a+c,-1,1);return[Math.asin(_),Math.asin(u)]},ProjLAEA.prototype.inversePhiAtX_=function(t,o){const e=this.dMath_.cosR_lower(t,o)*this.sin_phi0_,r=this.dMath_.cosR_upper(t,o)*this.sin_phi0_,i=e<=r?r:e,a=e<=r?e:r,n=Math.abs(this.dMath_.X_lower(t)),s=Math.abs(this.dMath_.X_upper(t)),h=n<=s?s:n,c=n<=s?n:s,u=Math.abs(this.cos_phi0_),_=h*this.dMath_.sinR_divR_upper(t,o)*u,l=c*this.dMath_.sinR_divR_lower(t,o)*u,p=0<=t*this.cos_phi0_?1:-1,M=0<p?+_:-l,v=0<p?+l:-_,d=ProjMath.clamp(i+M,-1,1),P=ProjMath.clamp(a+v,-1,1);return[Math.asin(P),Math.asin(d)]},ProjLAEA.prototype.getVertexShaderStr=function(){return ProjLAEA.VERTEX_SHADER_STR},ProjLAEA.prototype.getFragmentShaderStr=function(){return ProjLAEA.FRAGMENT_SHADER_STR},ProjLAEA.VERTEX_SHADER_STR=["precision highp float;","attribute float aCoordX;","attribute float aCoordY;","uniform mat3 uFwdTransform;","uniform vec2 uProjCenter;","varying vec2 vCoord;","varying float vInRange;","uniform float uPointSize;","uniform lowp int uCoordType;","uniform lowp int uTextureType;","const float pi = 3.141592653589793;","const float epsilon = 0.001;","const float xyDomain = 0.86 * 0.707106781 * pi;","vec2 proj_forward(vec2 center, vec2 lp)","{","  float sinPhi0 = sin(center.y);","  float cosPhi0 = cos(center.y);","  float sinPhi = sin(lp.y);","  float cosPhi = cos(lp.y);","  float sinLam = sin(lp.x - center.x);","  float cosLam = cos(lp.x - center.x);","  float v = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosLam;","  float x = cosPhi * sinLam;","  float y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosLam;","  if ( v < -1.0 + epsilon ) {","    return 2.0 * normalize(vec2(x, y));","  }","  float k = sqrt(2.0 / (1.0 + v));","  return k * vec2(x, y);","}","float check_xy_range(vec2 xy)","{","  return 1.0 - step(xyDomain, length(xy));","}","void main()","{","  vInRange = 1.0;","  vec3 pos;","  if ( uTextureType == 2 || uCoordType == 2 ) {","    pos = vec3(aCoordX, aCoordY, 1.0);","  } else if ( uCoordType == 1 ) {","    pos = uFwdTransform * vec3(aCoordX, aCoordY, 1.0);","    vInRange = check_xy_range(vec2(aCoordX, aCoordY));","  } else {","    vec2 xy = proj_forward(uProjCenter, vec2(aCoordX, aCoordY));","    vInRange = check_xy_range(xy);","    pos = uFwdTransform * vec3(xy.x, xy.y, 1.0);","  }","  vCoord = pos.xy;","  gl_Position = vec4(pos, 1.0);","  gl_PointSize = uPointSize;","}"].join("\n"),ProjLAEA.FRAGMENT_SHADER_STR=["precision highp float;","uniform mat3 uInvTransform;","uniform vec2 uDataCoord1;","uniform vec2 uDataCoord2;","uniform vec2 uClipCoord1;","uniform vec2 uClipCoord2;","uniform lowp int uCoordType;","uniform lowp int uTextureType;","uniform sampler2D uTexture;","uniform vec2 uCanvasSize;","uniform float uGraticuleIntervalDeg;","uniform vec2 uProjCenter;","uniform vec4 uColor;","uniform float uOpacity;","varying vec2 vCoord;","varying float vInRange;","const float pi = 3.141592653589793;","const float epsilon = 0.00000001;","const float blurRatio = 0.015;","const float xyRadius = 2.0;","vec2 proj_inverse(vec2 center, vec2 xy)","{","  float sinPhi0 = sin(center.y);","  float cosPhi0 = cos(center.y);","  float rho = length(xy);","  if ( rho < epsilon ) {","    return center;","  }","  if ( rho - epsilon > xyRadius ) {","    rho = xyRadius;","  }","  float c_rh = 2.0 * asin( clamp( rho/2.0, -1.0, 1.0) );","  float cos_c = cos(c_rh);","  float sin_c = sin(c_rh);","  float phi = asin( clamp( cos_c * sinPhi0 + xy.y * sin_c * cosPhi0 / rho, -1.0, 1.0 ) );","  float lam = mod( center.x + atan( xy.x * sin_c, rho * cosPhi0 * cos_c - xy.y * sinPhi0 * sin_c ) + pi, 2.0 * pi ) - pi;","  return vec2(lam, phi);","}","float inner_xy(vec2 xy)","{","  return 1.0 - smoothstep( (1.0 - blurRatio) * xyRadius, (1.0 + blurRatio) * xyRadius, length(xy) );","}","float validate_xy(vec2 xy)","{","  return 1.0 - step(xyRadius, length(xy));","}","vec2 graticule_level(vec2 lp, vec2 baseLonLat) {","  vec2 lonlat = degrees(lp);","  if ( 135.0 < abs(baseLonLat.x) ) {","    lonlat.x = mod(lonlat.x + 360.0, 360.0);","  }","  return floor(lonlat / uGraticuleIntervalDeg);","}","bool render_graticule() {","  vec2 viewCoord = (uInvTransform * vec3(vCoord.x, vCoord.y, 1.0)).xy;","  if ( validate_xy(viewCoord) == 0.0 ) {","    return false;","  }","  vec2 lp = proj_inverse(uProjCenter, viewCoord);","  vec2 baseLonLat = degrees(lp);","  float absLat = abs(baseLonLat.y);","  if (81.0 < absLat) {","    return false;","  }","  vec2 v1 = (uInvTransform * vec3(vCoord.x, vCoord.y + 1.0/uCanvasSize.y, 1.0)).xy;","  vec2 v3 = (uInvTransform * vec3(vCoord.x - 1.0/uCanvasSize.x, vCoord.y, 1.0)).xy;","  vec2 v5 = (uInvTransform * vec3(vCoord.x + 1.0/uCanvasSize.x, vCoord.y, 1.0)).xy;","  vec2 v7 = (uInvTransform * vec3(vCoord.x, vCoord.y - 1.0/uCanvasSize.y, 1.0)).xy;","  if ( validate_xy(v1) == 0.0 ||  validate_xy(v3) == 0.0 || validate_xy(v5) == 0.0 || validate_xy(v7) == 0.0) {","    return false;","  }","  vec2 z = -4.0 * graticule_level(lp, baseLonLat);","  z += graticule_level(proj_inverse(uProjCenter, v1), baseLonLat);","  z += graticule_level(proj_inverse(uProjCenter, v3), baseLonLat);","  z += graticule_level(proj_inverse(uProjCenter, v5), baseLonLat);","  z += graticule_level(proj_inverse(uProjCenter, v7), baseLonLat);","  vec2 col = min(abs(z) / 1.9, 1.0);","  float alpha = 0.0;","  if (80.0 < absLat) {","    alpha = col.y;","  } else {","    alpha = max(col.x, col.y);","  }","  if (alpha == 0.0) {","    return false;","  }","  vec3 lineColor = vec3(0.8);","  gl_FragColor = vec4(lineColor, alpha * 0.75);","  return true;","}","void main()","{","  if ( vInRange < 0.5 ) {","    discard;","    return;","  }","  if ( 0.0 < uGraticuleIntervalDeg ) {","    bool rendered = render_graticule();","    if ( !rendered ) {","      discard;","    }","    return;","  }","  vec4 outColor;","  bool isDiscard = false;","  if ( uTextureType == 2 ) {","    float inXY = 1.0;","    vec2 coord;","    if ( uCoordType == 2 ) {","      coord = vCoord;","    } else {","      vec3 viewCoord = uInvTransform * vec3(vCoord.x, vCoord.y, 1.0);","      inXY = inner_xy(viewCoord.xy);","      if ( 0.0 < inXY ) {","        if ( uCoordType == 1 ) {","          coord = viewCoord.xy;","        } else if ( uCoordType == 0 ) {","          coord = proj_inverse(uProjCenter, viewCoord.xy);","        }","      } else {","        isDiscard = true;","        coord = vec2(0.0, 0.0);","      }","    }","    if ( !isDiscard ) {","      vec2 ts = (coord - uDataCoord1) / (uDataCoord2 - uDataCoord1);","      if ( uClipCoord1.x <= ts.x && uClipCoord1.y <= ts.y && ts.x <= uClipCoord2.x && ts.y <= uClipCoord2.y) {","        outColor = texture2D(uTexture, vec2(ts.x, 1.0 - ts.y)) * inXY;","        outColor.a = outColor.a * uOpacity;","      } else {","        isDiscard = true;","      }","    }","  } else if ( uTextureType == 1 ) {","    outColor = texture2D(uTexture, gl_PointCoord);","    isDiscard = (outColor.a == 0.0);","  } else {","    outColor = uColor;","    isDiscard = (outColor.a == 0.0);","  }","  if ( isDiscard ) {","    discard;","  } else {","    gl_FragColor = outColor;","  }","}"].join("\n"),"undefined"!=typeof module&&module.exports&&(module.exports=ProjLAEA,module.exports.ProjDiscreteMath=ProjDiscreteMath);