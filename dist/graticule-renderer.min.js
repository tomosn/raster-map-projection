/*!
 * RasterMapProjection v0.0.25  2018-12-30
 *   https://github.com/tomosn/raster-map-projection
 *   A JavaScript library for on-the-fly map projection of raster tiles using WebGL.
 * Copyright (C) 2016-2018 T.Seno
 * All rights reserved. 
 * @license GPL v3 License (http://www.gnu.org/licenses/gpl.html)
 */

"use strict";function GraticuleInterpolator(t,e,i,r){this.proj_=t,this.initDivNum_=e,this.threshold_=i,this.thSq_=i*i,this.maxRecursion_=r,this.longitudeProcessor_=function(t,e){const i=this.proj_.forward(e,t);return this.checkRange_(i)?i:null}.bind(this),this.latitudeProcessor_=function(t,e){const i=this.proj_.forward(t,e);return this.checkRange_(i)?i:null}.bind(this)}function GraticuleLine_(t,e,i){this.c0=t,this.length_=e,this.points_=i}function GraticuleRenderer(t,e){this.shaderProg_=t,this.proj_=e,this.unitLength_=Math.PI/8,this.separateThreshold_=Math.PI/8,this.interpolator_=new GraticuleInterpolator(this.proj_,8,Math.PI/8,8)}GraticuleInterpolator.prototype.checkRange_=function(t){return null!=t&&this.proj_.checkXYDomain(t.x,t.y,.9)},GraticuleInterpolator.prototype.createLongitudeLine=function(t,e,i){return this.createGraticuleLine_(t,e,i,this.longitudeProcessor_)},GraticuleInterpolator.prototype.createLatitudeLine=function(t,e,i){return this.createGraticuleLine_(t,e,i,this.latitudeProcessor_)},GraticuleInterpolator.prototype.interpolateValue_=function(t,e,i){return(t*(this.initDivNum_-i)+e*i)/this.initDivNum_},GraticuleInterpolator.prototype.searchEndPoint_=function(t,e,i,r){let n=null;for(let o=0;o<this.initDivNum_;++o){const s=this.interpolateValue_(e,i,o);let h=r(t,s);if(null!=h){if(null==n)return s;for(let e=0;e<this.initDivNum_;++e){const i=this.interpolateValue_(n,s,e);if(null!=(h=r(t,i)))return i}return s}n=s}return null},GraticuleInterpolator.prototype.createGraticuleLine_=function(t,e,i,r){const n=[],o=this.searchEndPoint_(t,e,i,r);if(null==o)return null;const s=this.searchEndPoint_(t,i,e,r);if(null==s)return null;let h=0,a=null,l=null;for(let e=0;e<=this.initDivNum_;++e){const i=this.interpolateValue_(o,s,e),u=r(t,i);if(null==u)continue;let c=0;if(null!=l&&(c=(u.x-l.x)*(u.x-l.x)+(u.y-l.y)*(u.y-l.y)),this.thSq_<c)h+=this.interpolateGraticule_(t,a,i,l,u,0,n,r);else{const t=Math.sqrt(c);n.push([u,i,t]),h+=t}l=u,a=i}return new GraticuleLine_(t,h,n)},GraticuleInterpolator.prototype.interpolateGraticule_=function(t,e,i,r,n,o,s,h){let a=(e+i)/2,l=h(t,a);if(null==l&&(l=h(t,a=(2*e+i)/3)),null==l&&(l=h(t,a=(e+2*i)/3)),null==l){const t=(r.x-n.x)*(r.x-n.x)+(r.y-n.y)*(r.y-n.y),e=Math.sqrt(t);return s.push([n,i,e]),e}const u=(r.x-l.x)*(r.x-l.x)+(r.y-l.y)*(r.y-l.y),c=(n.x-l.x)*(n.x-l.x)+(n.y-l.y)*(n.y-l.y);if(this.maxRecursion_<=o){const t=Math.sqrt(u),e=Math.sqrt(c);return s.push([l,a,t]),s.push([n,i,e]),t+e}let p=0;if(u<=this.thSq_){const t=Math.sqrt(u);s.push([l,a,t]),p+=t}else p+=this.interpolateGraticule_(t,e,a,r,l,o+1,s,h);if(c<=this.thSq_){const t=Math.sqrt(c);s.push([n,i,t]),p+=t}else p+=this.interpolateGraticule_(t,a,i,l,n,o+1,s,h);return p},GraticuleLine_.prototype.generateVariables_=function(t,e,i){const r=this.points_[t][1],n=this.points_[e][1],o=new Array(i);for(let t=0;t<=i-1;t++)o[t]=(r*(i-1-t)+n*t)/(i-1);return o},GraticuleLine_.prototype.generateLists=function(t,e,i){const r=[];let n=0,o=0;for(let s=1;s<this.points_.length;s++){const h=this.points_[s];e<h[2]?(n+1<s&&this.generateEachLists_(n,s-1,o,t,i,r),n=s,o=0):(o+=h[2],this.points_.length-1<=s&&n<s&&this.generateEachLists_(n,s,o,t,i,r))}return r},GraticuleLine_.prototype.generateEachLists_=function(t,e,i,r,n,o){let s=i,h=i<r?1:Math.round(i/r),a=t;for(;0<h;){let t,i=0;if(h<=1)t=e;else{const r=s/h;for(t=a+1;t<=e&&!(r<=(i+=this.points_[t][2])||e<=t);t++);}if(o.push(this.generateVariables_(a,t,n)),h--,s-=i,e<=(a=t))break}},GraticuleRenderer.prototype.renderLines=function(t,e,i){this.renderLatitudeLines(t,e,i),this.renderLongitudeLines(t,e,i)},GraticuleRenderer.prototype.renderLatitudeLines=function(t,e,i){const r=Math.max(-80*Math.PI/180,e.phi[0]),n=Math.min(80*Math.PI/180,e.phi[1]),o=[];let s;if(s=r<0&&0<n?[r,0,n]:[r,n],r<-this.proj_.phi0&&-this.proj_.phi0<n&&0!==this.proj_.phi0)for(let t=1;t<=s.length;t++)if(-this.proj_.phi0<s[t]){s.splice(t,0,-this.proj_.phi0);break}for(let t=1;t<s.length;t++)o.push([s[t-1],s[t]]);const h=i*Math.floor(180*e.lambda[0]/Math.PI/i),a=180*e.lambda[1]/Math.PI,l=this.shaderProg_.coordsBuffer_.maxNum*this.shaderProg_.coordsBuffer_.dimension;this.shaderProg_.prepareRenderLatitudeLine();for(let e=h;e<=a;e+=i){const i=e*Math.PI/180;for(let e=0;e<o.length;e++){const r=o[e],n=this.interpolator_.createLatitudeLine(i,r[0],r[1]);if(null==n)continue;const s=n.generateLists(this.unitLength_,this.separateThreshold_,l);for(let e=0;e<s.length;e++)this.shaderProg_.renderLatitudeLine(i,s[e],t)}}},GraticuleRenderer.prototype.renderLongitudeLines=function(t,e,i){const r=ProjMath.normalizeLambda(this.proj_.lam0-Math.PI),n=[];e.lambda[0]<r&&r<e.lambda[1]?(n.push([e.lambda[0],r]),n.push([r,e.lambda[1]])):r<e.lambda[1]-2*Math.PI?(n.push([r,e.lambda[1]-2*Math.PI]),n.push([e.lambda[0],r+2*Math.PI])):n.push(e.lambda);const o=i*Math.floor(180*e.phi[0]/Math.PI/i),s=Math.min(80,180*e.phi[1]/Math.PI),h=this.shaderProg_.coordsBuffer_.maxNum*this.shaderProg_.coordsBuffer_.dimension;this.shaderProg_.prepareRenderLongitudeLine();for(let e=o;e<=s;e+=i){const i=e*Math.PI/180;for(let e=0;e<n.length;e++){const r=n[e],o=this.interpolator_.createLongitudeLine(i,r[0],r[1]);if(null==o)continue;const s=o.generateLists(this.unitLength_,this.separateThreshold_,h);for(let e=0;e<s.length;e++)this.shaderProg_.renderLongitudeLine(i,s[e],t)}}},"undefined"!=typeof module&&module.exports&&(module.exports=GraticuleInterpolator);