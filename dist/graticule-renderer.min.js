/*!
 * RasterMapProjection v0.0.26  2018-12-30
 *   https://github.com/tomosn/raster-map-projection
 *   A JavaScript library for on-the-fly map projection of raster tiles using WebGL.
 * Copyright (C) 2016-2018 T.Seno
 * All rights reserved. 
 * @license GPL v3 License (http://www.gnu.org/licenses/gpl.html)
 */

"use strict";function GraticuleInterpolator(t,e,r,i){this.proj_=t,this.initDivNum_=e,this.threshold_=r,this.thSq_=r*r,this.maxRecursion_=i,this.longitudeProcessor_=function(t,e){const r=this.proj_.forward(e,t);return this.checkRange_(r)?r:null}.bind(this),this.latitudeProcessor_=function(t,e){const r=this.proj_.forward(t,e);return this.checkRange_(r)?r:null}.bind(this)}function GraticuleLine_(t,e,r){this.c0=t,this.length_=e,this.points_=r}function GraticuleRenderer(t,e){this.shaderProg_=t,this.proj_=e,this.separateThreshold_=Math.PI/8,this.interpolator_=new GraticuleInterpolator(this.proj_,8,Math.PI/8,8)}GraticuleInterpolator.prototype.checkRange_=function(t){return null!=t&&this.proj_.checkXYDomain(t.x,t.y,.9)},GraticuleInterpolator.prototype.createLongitudeLine=function(t,e,r){return this.createGraticuleLine_(t,e,r,this.longitudeProcessor_)},GraticuleInterpolator.prototype.createLatitudeLine=function(t,e,r){return this.createGraticuleLine_(t,e,r,this.latitudeProcessor_)},GraticuleInterpolator.prototype.interpolateValue_=function(t,e,r){return(t*(this.initDivNum_-r)+e*r)/this.initDivNum_},GraticuleInterpolator.prototype.searchEndPoint_=function(t,e,r,i){let n=null;for(let o=0;o<this.initDivNum_;++o){const s=this.interpolateValue_(e,r,o);let a=i(t,s);if(null!=a){if(null==n)return s;for(let e=0;e<this.initDivNum_;++e){const r=this.interpolateValue_(n,s,e);if(null!=(a=i(t,r)))return r}return s}n=s}return null},GraticuleInterpolator.prototype.createGraticuleLine_=function(t,e,r,i){const n=[],o=this.searchEndPoint_(t,e,r,i);if(null==o)return null;const s=this.searchEndPoint_(t,r,e,i);if(null==s)return null;let a=0,h=null,l=null;for(let e=0;e<=this.initDivNum_;++e){const r=this.interpolateValue_(o,s,e),u=i(t,r);if(null==u)continue;let c=0;if(null!=l&&(c=(u.x-l.x)*(u.x-l.x)+(u.y-l.y)*(u.y-l.y)),this.thSq_<c)a+=this.interpolateGraticule_(t,h,r,l,u,0,n,i);else{const t=Math.sqrt(c);n.push([u,r,t]),a+=t}l=u,h=r}return new GraticuleLine_(t,a,n)},GraticuleInterpolator.prototype.interpolateGraticule_=function(t,e,r,i,n,o,s,a){let h=(e+r)/2,l=a(t,h);if(null==l&&(l=a(t,h=(2*e+r)/3)),null==l&&(l=a(t,h=(e+2*r)/3)),null==l){const t=(i.x-n.x)*(i.x-n.x)+(i.y-n.y)*(i.y-n.y),e=Math.sqrt(t);return s.push([n,r,e]),e}const u=(i.x-l.x)*(i.x-l.x)+(i.y-l.y)*(i.y-l.y),c=(n.x-l.x)*(n.x-l.x)+(n.y-l.y)*(n.y-l.y);if(this.maxRecursion_<=o){const t=Math.sqrt(u),e=Math.sqrt(c);return s.push([l,h,t]),s.push([n,r,e]),t+e}let p=0;if(u<=this.thSq_){const t=Math.sqrt(u);s.push([l,h,t]),p+=t}else p+=this.interpolateGraticule_(t,e,h,i,l,o+1,s,a);if(c<=this.thSq_){const t=Math.sqrt(c);s.push([n,r,t]),p+=t}else p+=this.interpolateGraticule_(t,h,r,l,n,o+1,s,a);return p},GraticuleLine_.prototype.generateVariables_=function(t,e,r){const i=this.points_[t][1],n=this.points_[e][1],o=new Array(r);for(let t=0;t<=r-1;t++)o[t]=(i*(r-1-t)+n*t)/(r-1);return o},GraticuleLine_.prototype.generateLists=function(t,e,r){const i=[];let n=0,o=0;for(let s=1;s<this.points_.length;s++){const a=this.points_[s];e<a[2]?(n+1<s&&this.generateEachLists_(n,s-1,o,t,r,i),n=s,o=0):(o+=a[2],this.points_.length-1<=s&&n<s&&this.generateEachLists_(n,s,o,t,r,i))}return i},GraticuleLine_.prototype.generateEachLists_=function(t,e,r,i,n,o){let s=r,a=r<i?1:Math.round(r/i),h=t;for(;0<a;){let t,r=0;if(a<=1)t=e;else{const i=s/a;for(t=h+1;t<=e&&!(i<=(r+=this.points_[t][2])||e<=t);t++);}if(o.push(this.generateVariables_(h,t,n)),a--,s-=r,e<=(h=t))break}},GraticuleRenderer.prototype.calcUnitLength_=function(t){const e=t[2]-t[0],r=t[3]-t[1];return Math.sqrt(e*e+r*r)/4},GraticuleRenderer.prototype.renderLines=function(t,e,r){const i=this.calcUnitLength_(t);this.renderLatitudeLines(t,e,r,i),this.renderLongitudeLines(t,e,r,i)},GraticuleRenderer.prototype.renderLatitudeLines=function(t,e,r,i){const n=Math.max(-80*Math.PI/180,e.phi[0]),o=Math.min(80*Math.PI/180,e.phi[1]),s=[];let a;if(a=n<0&&0<o?[n,0,o]:[n,o],n<-this.proj_.phi0&&-this.proj_.phi0<o&&0!==this.proj_.phi0)for(let t=1;t<=a.length;t++)if(-this.proj_.phi0<a[t]){a.splice(t,0,-this.proj_.phi0);break}for(let t=1;t<a.length;t++)s.push([a[t-1],a[t]]);const h=r*Math.floor(180*e.lambda[0]/Math.PI/r),l=180*e.lambda[1]/Math.PI,u=this.shaderProg_.coordsBuffer_.maxNum*this.shaderProg_.coordsBuffer_.dimension;this.shaderProg_.prepareRenderLatitudeLine();for(let e=h;e<=l;e+=r){const r=e*Math.PI/180;for(let e=0;e<s.length;e++){const n=s[e],o=this.interpolator_.createLatitudeLine(r,n[0],n[1]);if(null==o)continue;const a=o.generateLists(i,this.separateThreshold_,u);for(let e=0;e<a.length;e++)this.shaderProg_.renderLatitudeLine(r,a[e],t)}}},GraticuleRenderer.prototype.renderLongitudeLines=function(t,e,r,i){const n=ProjMath.normalizeLambda(this.proj_.lam0-Math.PI),o=[];e.lambda[0]<n&&n<e.lambda[1]?(o.push([e.lambda[0],n]),o.push([n,e.lambda[1]])):n<e.lambda[1]-2*Math.PI?(o.push([n,e.lambda[1]-2*Math.PI]),o.push([e.lambda[0],n+2*Math.PI])):o.push(e.lambda);const s=r*Math.floor(180*e.phi[0]/Math.PI/r),a=Math.min(80,180*e.phi[1]/Math.PI),h=this.shaderProg_.coordsBuffer_.maxNum*this.shaderProg_.coordsBuffer_.dimension;this.shaderProg_.prepareRenderLongitudeLine();for(let e=s;e<=a;e+=r){const r=e*Math.PI/180;for(let e=0;e<o.length;e++){const n=o[e],s=this.interpolator_.createLongitudeLine(r,n[0],n[1]);if(null==s)continue;const a=s.generateLists(i,this.separateThreshold_,h);for(let e=0;e<a.length;e++)this.shaderProg_.renderLongitudeLine(r,a[e],t)}}},"undefined"!=typeof module&&module.exports&&(module.exports=GraticuleInterpolator);