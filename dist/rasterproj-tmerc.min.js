/*!
 * Raster Map Projection v0.0.17  2017-07-23
 *   https://github.com/tomosn/raster-map-projection
 * Copyright (C) 2016-2017 T.Seno
 * All rights reserved. 
 * @license GPL v3 License (http://www.gnu.org/licenses/gpl.html)
 */

"use strict";if("undefined"!=typeof module&&module.exports)var ProjMath=require("./rasterproj-common.js");RasterMapProjection.createProjection=function(r,t,o){return new ProjTMERC(r,t)},RasterMapProjection.createShaderProgram=function(r){return new TMERCProjShaderProgram(r)};var TMERCProjShaderProgram=function(r){ProjShaderProgram.call(this,r),this.locUnifBaseY_=null};Object.setPrototypeOf(TMERCProjShaderProgram.prototype,ProjShaderProgram.prototype),TMERCProjShaderProgram.prototype.init=function(r,t){var o=ProjShaderProgram.prototype.init.call(this,r,t);return o&&(this.locUnifBaseY_=this.gl_.getUniformLocation(this.program_,"uBaseY")),o},TMERCProjShaderProgram.prototype.renderLatitudeLine=function(r,t,o){var e=0,a=0;o&&(e=this.getPeriodIndexY_(o[1]),a=this.getPeriodIndexY_(o[3]));var i=(t[0]+t[t.length-1])/2,n=0;0<i?n=Math.PI/2:i<0&&(n=-Math.PI/2);for(var h=e;h<=a;++h)this.gl_.uniform1f(this.locUnifBaseY_,2*Math.PI*h+n),ProjShaderProgram.prototype.renderLatitudeLine.call(this,r,t)},TMERCProjShaderProgram.prototype.renderLongitudeLine=function(r,t,o){var e=0,a=0;o&&(e=this.getPeriodIndexY_(o[1]),a=this.getPeriodIndexY_(o[3]));for(var i=e;i<=a;++i)this.gl_.uniform1f(this.locUnifBaseY_,2*Math.PI*i+0),ProjShaderProgram.prototype.renderLongitudeLine.call(this,r,t)},TMERCProjShaderProgram.prototype.getPeriodIndexY_=function(r){return Math.floor((r+Math.PI)/(2*Math.PI))};var ProjTMERC=function(r,t){this.lam0=r,this.phi0=t};ProjTMERC.RANGE_RECTANGLE=[-Math.PI,-Math.PI,+Math.PI,+Math.PI],ProjTMERC.prototype.getRange=function(){return ProjTMERC.RANGE_RECTANGLE.slice(0)},ProjTMERC.prototype.getProjCenter=function(){return{lambda:this.lam0,phi:this.phi0}},ProjTMERC.prototype.setProjCenter=function(r,t){this.lam0=r,this.phi0=t},ProjTMERC.prototype.checkXYDomain=function(r,t,o){return!0},ProjTMERC.prototype.forward=function(r,t){var o=Math.cos(t)*Math.sin(r-this.lam0),e=Math.log((1+o)/(1-o))/2,a=Math.atan2(Math.tan(t),Math.cos(r-this.lam0))-this.phi0;return(a<-Math.PI||Math.PI<=a)&&(a-=2*Math.PI*Math.floor((a+Math.PI)/(2*Math.PI))),{x:e,y:a}},ProjTMERC.prototype.inverse=function(r,t){var o=this.inverse_phi_(r,t),e=this.inverse_lambda_(r,t);return(e<-Math.PI||Math.PI<=e)&&(e-=2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))),{lambda:e,phi:o}},ProjTMERC.prototype.inverse_phi_=function(r,t){return Math.asin(ProjMath.clamp(Math.sin(t+this.phi0)/Math.cosh(r),-1,1))},ProjTMERC.prototype.inverse_lambda_=function(r,t){return Math.atan2(Math.sinh(r),Math.cos(t+this.phi0))+this.lam0},ProjTMERC.prototype.inverse_lambda_atY_=function(r,t){var o=Math.cos(t+this.phi0);if(0===o)return 0<=r?Math.PI/2:-Math.PI/2;var e=Math.sinh(r),a=Math.atan2(e,o)+this.lam0;return o<0&&e<0?a+2*Math.PI:a},ProjTMERC.prototype.containsNorthPole_=function(r,t,o,e){if(o<0||0<r)return!1;for(var a=(2*Math.floor((t+this.phi0)/(2*Math.PI)-.5)+.5)*Math.PI-this.phi0,i=0;i<256;++i){var n=a+2*Math.PI*i;if(e<n)break;if(t<=n&&n<=e)return!0}return!1},ProjTMERC.prototype.containsSouthPole_=function(r,t,o,e){if(o<0||0<r)return!1;for(var a=(2*Math.floor((t+this.phi0)/(2*Math.PI)+.5)-.5)*Math.PI-this.phi0,i=0;i<256;++i){var n=a+2*Math.PI*i;if(e<n)break;if(t<=n&&n<=e)return!0}return!1},ProjTMERC.prototype.inverseBoundingBox=function(r,t,o,e){var a=r<=o?r:o,i=r<=o?o:r,n=t<=e?t:e,h=t<=e?e:t;if(a<=0&&0<=i){var s=this.containsNorthPole_(a,n,i,h),l=this.containsSouthPole_(a,n,i,h);if(s&&l)return{lambda:[-Math.PI,+Math.PI],phi:[-Math.PI/2,+Math.PI/2]};if(s||l){var u=this.inversePhiRange_([a,i],[n,h]);return s?{lambda:[-Math.PI,+Math.PI],phi:[u[0],Math.PI/2]}:{lambda:[-Math.PI,+Math.PI],phi:[-Math.PI/2,u[1]]}}}var p=this.inversePhiRange_([a,i],[n,h]),P=this.inverseLambdaRange_([a,i],[n,h]);return P=this.normalizeLambdaRange_(P),2*Math.PI<P[1]-P[0]&&(P=[-Math.PI,Math.PI]),{lambda:P,phi:p}},ProjTMERC.prototype.mergeRange_=function(r,t){var o=null;return null==r?o=t:null!=t&&(o=r,t[0]<o[0]&&(o[0]=t[0]),o[1]<t[1]&&(o[1]=t[1])),o},ProjTMERC.prototype.normalizeLambdaRange_=function(r){var t=r[0];if(-Math.PI<=t&&t<Math.PI)return r;var o=2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI));return[r[0]-o,r[1]-o]},ProjTMERC.prototype.inverseLambdaRange_=function(r,t){var o=r[0]<=r[1]?r[0]:r[1],e=r[0]<=r[1]?r[1]:r[0],a=t[0]<=t[1]?t[0]:t[1],i=t[0]<=t[1]?t[1]:t[0],n=this.inverseLambdaRangeAtY_([o,e],[a,i]),h=this.inverseLambdaRangeAtX_([a,i],[o,e]);return this.mergeRange_(h,n)},ProjTMERC.prototype.inverseLambdaRangeAtY_=function(r,t){for(var o=r[0]<=r[1]?r[0]:r[1],e=r[0]<=r[1]?r[1]:r[0],a=o<=0&&0<=e,i=t.length,n=null,h=null,s=0;s<i;s++){var l=t[s],u=a?this.inverse_lambda_atY_(o,l):this.inverse_lambda_(o,l);(null===n||u<n)&&(n=u),(null===h||h<u)&&(h=u),(u=a?this.inverse_lambda_atY_(e,l):this.inverse_lambda_(e,l))<n&&(n=u),h<u&&(h=u)}if(n<-Math.PI||Math.PI<=n){var p=2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI));n-=p,h-=p}return[n,h]},ProjTMERC.prototype.inverseLambdaRangeAtX_=function(r,t){for(var o=r[0]<=r[1]?r[0]:r[1],e=r[0]<=r[1]?r[1]:r[0],a=Math.PI*Math.floor((o+this.phi0)/Math.PI)-this.phi0,i=t.length,n=null,h=null,s=0;s<i;s++){var l=t[s],u=this.inverse_lambda_(l,o);(null===n||u<n)&&(n=u),(null===h||h<u)&&(h=u),(u=this.inverse_lambda_(l,e))<n&&(n=u),h<u&&(h=u);for(var p=1;p<=2;p++){var P=a+Math.PI*p;if(P<o)throw new Error("hoge!");if(e<P)break;(u=this.inverse_lambda_(l,P))<n&&(n=u),h<u&&(h=u)}}if(n<-Math.PI||Math.PI<=n){var f=2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI));n-=f,h-=f}return[n,h]},ProjTMERC.prototype.inversePhiRange_=function(r,t){var o=r[0]<=r[1]?r[0]:r[1],e=r[0]<=r[1]?r[1]:r[0],a=t[0]<=t[1]?t[0]:t[1],i=t[0]<=t[1]?t[1]:t[0],n=this.inversePhiRangeAtY_([o,e],[a,i]),h=this.inversePhiRangeAtX_([a,i],[o,e]);return this.mergeRange_(h,n)},ProjTMERC.prototype.inversePhiRangeAtY_=function(r,t){for(var o=r[0]<=r[1]?r[0]:r[1],e=r[0]<=r[1]?r[1]:r[0],a=t.length,i=null,n=null,h=0;h<a;h++){var s=t[h],l=this.inverse_phi_(o,s);(null===i||l<i)&&(i=l),(null===n||n<l)&&(n=l),(l=this.inverse_phi_(e,s))<i&&(i=l),n<l&&(n=l),o<0&&0<e&&((l=this.inverse_phi_(0,s))<i&&(i=l),n<l&&(n=l))}return[i,n]},ProjTMERC.prototype.inversePhiRangeAtX_=function(r,t){for(var o=r[0]<=r[1]?r[0]:r[1],e=r[0]<=r[1]?r[1]:r[0],a=Math.PI*(Math.floor((o+this.phi0)/Math.PI+.5)-.5)-this.phi0,i=t.length,n=null,h=null,s=0;s<i;s++){var l=t[s],u=this.inverse_phi_(l,o);(null===n||u<n)&&(n=u),(null===h||h<u)&&(h=u),(u=this.inverse_phi_(l,e))<n&&(n=u),h<u&&(h=u);for(var p=1;p<=2;p++){var P=a+Math.PI*p;if(P<o)throw new Error("hoge!");if(e<P)break;(u=this.inverse_phi_(l,P))<n&&(n=u),h<u&&(h=u)}}return[n,h]},ProjTMERC.prototype.getVertexShaderStr=function(){return ProjTMERC.VERTEX_SHADER_STR},ProjTMERC.prototype.getFragmentShaderStr=function(){return ProjTMERC.FRAGMENT_SHADER_STR},ProjTMERC.VERTEX_SHADER_STR=["precision highp float;","attribute float aCoordX;","attribute float aCoordY;","uniform mat3 uFwdTransform;","uniform vec2 uProjCenter;","varying vec2 vCoord;","varying float vInRange;","uniform float uBaseY;","uniform float uPointSize;","uniform lowp int uCoordType;","uniform lowp int uTextureType;","const float pi = 3.141592653589793;","const float epsilon = 0.001;","vec2 proj_forward(vec2 center, vec2 lp, float baseY)","{","  float b = cos(lp.y) * sin(lp.x - center.x);","  float x = log((1.0 + b) / (1.0 - b)) / 2.0;","  float y = atan(tan(lp.y), cos(lp.x - center.x));","  float dy = y - baseY + pi;","  if ( dy < 0.0 || 2.0*pi <= dy ) {","    y = y - 2.0*pi * floor(dy / (2.0*pi));","  }","  return vec2(x, y - center.y);","}","float check_xy_range(vec2 xy)","{","  return step(-pi, xy.x) - step(pi, xy.x);","}","void main()","{","  vInRange = 1.0;","  vec3 pos;","  if ( uTextureType == 2 || uCoordType == 2 ) {","    pos = vec3(aCoordX, aCoordY, 1.0);","  } else if ( uCoordType == 1 ) {","    pos = uFwdTransform * vec3(aCoordX, aCoordY, 1.0);","    vInRange = check_xy_range(vec2(aCoordX, aCoordY));","  } else {","    vec2 xy = proj_forward(uProjCenter, vec2(aCoordX, aCoordY), uBaseY);","    vInRange = check_xy_range(xy);","    pos = uFwdTransform * vec3(xy.x, xy.y, 1.0);","  }","  vCoord = pos.xy;","  gl_Position = vec4(pos, 1.0);","  gl_PointSize = uPointSize;","}"].join("\n"),ProjTMERC.FRAGMENT_SHADER_STR=["precision highp float;","uniform mat3 uInvTransform;","uniform vec2 uDataCoord1;","uniform vec2 uDataCoord2;","uniform lowp int uCoordType;","uniform lowp int uTextureType;","uniform sampler2D uTexture;","uniform vec2 uProjCenter;","uniform vec4 uColor;","varying vec2 vCoord;","varying float vInRange;","const float pi = 3.141592653589793;","const float epsilon = 0.00000001;","const float blurRatio = 0.015;","const float xyRadius = pi;","vec2 proj_inverse(vec2 center, vec2 xy)","{","  float d = xy.y + center.y;","  float ep = exp(xy.x);","  float em = exp(-xy.x);","  float ch = (ep + em) / 2.0;","  float sh = (ep - em) / 2.0;","  float phi = asin( clamp( sin(d) / ch, -1.0, 1.0 ) );","  float lam = mod( center.x + atan( sh, cos(d) ) + pi, 2.0 * pi ) - pi;","  return vec2(lam, phi);","}","float inner_xy(vec2 xy)","{","  return 1.0;","}","void main()","{","  if ( vInRange < 0.5 ) {","    discard;","    return;","  }","  vec4 outColor;","  bool isDiscard = false;","  if ( uTextureType == 2 ) {","    float inXY = 1.0;","    vec2 coord;","    if ( uCoordType == 2 ) {","      coord = vCoord;","    } else {","      vec3 viewCoord = uInvTransform * vec3(vCoord.x, vCoord.y, 1.0);","      inXY = inner_xy(viewCoord.xy);","      if ( 0.0 < inXY ) {","        if ( uCoordType == 1 ) {","          coord = viewCoord.xy;","        } else if ( uCoordType == 0 ) {","          coord = proj_inverse(uProjCenter, viewCoord.xy);","        }","      } else {","        isDiscard = true;","        coord = vec2(0.0, 0.0);","      }","    }","    if ( !isDiscard ) {","      vec2 ts = (coord - uDataCoord1) / (uDataCoord2 - uDataCoord1);","      if ( 0.0 <= ts.x && 0.0 <= ts.y && ts.x <= 1.0 && ts.y <= 1.0) {","        outColor = texture2D(uTexture, vec2(ts.x, 1.0 - ts.y)) * inXY;","      } else {","        isDiscard = true;","      }","    }","  } else if ( uTextureType == 1 ) {","    outColor = texture2D(uTexture, gl_PointCoord);","    isDiscard = (outColor.a == 0.0);","  } else {","    outColor = uColor;","    isDiscard = (outColor.a == 0.0);","  }","  if ( isDiscard ) {","    discard;","  } else {","    gl_FragColor = outColor;","  }","}"].join("\n"),"undefined"!=typeof module&&module.exports&&(module.exports=ProjTMERC);