/*!
 * Raster Map Projection v0.0.14  2017-05-07
 *   https://github.com/tomosn/raster-map-projection
 * Copyright (C) 2016-2017 T.Seno
 * All rights reserved. 
 * @license GPL v3 License (http://www.gnu.org/licenses/gpl.html)
 */
"use strict";if("undefined"!=typeof module&&module.exports)var ProjMath=require("./rasterproj-common.js");var ProjTMERC=function(a,b){this.lam0=a,this.phi0=b};ProjTMERC.RANGE_RECTANGLE=[-Math.PI,-Math.PI,+Math.PI,+Math.PI],ProjTMERC.prototype.getRange=function(){return ProjTMERC.RANGE_RECTANGLE.slice(0)},ProjTMERC.prototype.getProjCenter=function(){return{lambda:this.lam0,phi:this.phi0}},ProjTMERC.prototype.setProjCenter=function(a,b){this.lam0=a,this.phi0=b},ProjTMERC.prototype.checkXYDomain=function(a,b,c){return!0},ProjTMERC.prototype.forward=function(a,b){var c=Math.cos(b)*Math.sin(a-this.lam0),d=Math.log((1+c)/(1-c))/2,e=Math.atan2(Math.tan(b),Math.cos(a-this.lam0))-this.phi0;return(e<-Math.PI||Math.PI<=e)&&(e-=2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))),{x:d,y:e}},ProjTMERC.prototype.inverse=function(a,b){var c=this.inverse_phi_(a,b),d=this.inverse_lambda_(a,b);return(d<-Math.PI||Math.PI<=d)&&(d-=2*Math.PI*Math.floor((d+Math.PI)/(2*Math.PI))),{lambda:d,phi:c}},ProjTMERC.prototype.inverse_phi_=function(a,b){return Math.asin(ProjMath.clamp(Math.sin(b+this.phi0)/Math.cosh(a),-1,1))},ProjTMERC.prototype.inverse_lambda_=function(a,b){return Math.atan2(Math.sinh(a),Math.cos(b+this.phi0))+this.lam0},ProjTMERC.prototype.inverse_lambda_atY_=function(a,b){var c=Math.cos(b+this.phi0);if(0===c)return 0<=a?Math.PI/2:-Math.PI/2;var d=Math.sinh(a),e=Math.atan2(d,c)+this.lam0;return c<0&&d<0?e+2*Math.PI:e},ProjTMERC.prototype.containsNorthPole_=function(a,b,c,d){if(c<0||0<a)return!1;for(var e=(2*Math.floor((b+this.phi0)/(2*Math.PI)-.5)+.5)*Math.PI-this.phi0,f=0;f<256;++f){var g=e+2*Math.PI*f;if(d<g)break;if(b<=g&&g<=d)return!0}return!1},ProjTMERC.prototype.containsSouthPole_=function(a,b,c,d){if(c<0||0<a)return!1;for(var e=(2*Math.floor((b+this.phi0)/(2*Math.PI)+.5)-.5)*Math.PI-this.phi0,f=0;f<256;++f){var g=e+2*Math.PI*f;if(d<g)break;if(b<=g&&g<=d)return!0}return!1},ProjTMERC.prototype.inverseBoundingBox=function(a,b,c,d){var e=a<=c?a:c,f=a<=c?c:a,g=b<=d?b:d,h=b<=d?d:b;if(e<=0&&0<=f){var i=this.containsNorthPole_(e,g,f,h),j=this.containsSouthPole_(e,g,f,h);if(i&&j)return{lambda:[-Math.PI,+Math.PI],phi:[-Math.PI/2,+Math.PI/2]};if(i||j){var k=this.inversePhiRange_([e,f],[g,h]);return i?{lambda:[-Math.PI,+Math.PI],phi:[k[0],Math.PI/2]}:{lambda:[-Math.PI,+Math.PI],phi:[-Math.PI/2,k[1]]}}}var l=this.inversePhiRange_([e,f],[g,h]),m=this.inverseLambdaRange_([e,f],[g,h]);return m=this.normalizeLambdaRange_(m),2*Math.PI<m[1]-m[0]&&(m=[-Math.PI,Math.PI]),{lambda:m,phi:l}},ProjTMERC.prototype.mergeRange_=function(a,b){var c=null;return null==a?c=b:null!=b&&(c=a,b[0]<c[0]&&(c[0]=b[0]),c[1]<b[1]&&(c[1]=b[1])),c},ProjTMERC.prototype.normalizeLambdaRange_=function(a){var b=a[0];if(-Math.PI<=b&&b<Math.PI)return a;var c=2*Math.PI*Math.floor((b+Math.PI)/(2*Math.PI));return[a[0]-c,a[1]-c]},ProjTMERC.prototype.inverseLambdaRange_=function(a,b){var c=a[0]<=a[1]?a[0]:a[1],d=a[0]<=a[1]?a[1]:a[0],e=b[0]<=b[1]?b[0]:b[1],f=b[0]<=b[1]?b[1]:b[0],g=this.inverseLambdaRangeAtY_([c,d],[e,f]),h=this.inverseLambdaRangeAtX_([e,f],[c,d]),i=this.mergeRange_(h,g);return i},ProjTMERC.prototype.inverseLambdaRangeAtY_=function(a,b){for(var c=a[0]<=a[1]?a[0]:a[1],d=a[0]<=a[1]?a[1]:a[0],e=c<=0&&0<=d,f=b.length,g=null,h=null,i=0;i<f;i++){var j=b[i],k=e?this.inverse_lambda_atY_(c,j):this.inverse_lambda_(c,j);(null===g||k<g)&&(g=k),(null===h||h<k)&&(h=k),k=e?this.inverse_lambda_atY_(d,j):this.inverse_lambda_(d,j),k<g&&(g=k),h<k&&(h=k)}if(g<-Math.PI||Math.PI<=g){var l=2*Math.PI*Math.floor((g+Math.PI)/(2*Math.PI));g-=l,h-=l}return[g,h]},ProjTMERC.prototype.inverseLambdaRangeAtX_=function(a,b){for(var c=a[0]<=a[1]?a[0]:a[1],d=a[0]<=a[1]?a[1]:a[0],e=Math.PI*Math.floor((c+this.phi0)/Math.PI)-this.phi0,f=b.length,g=null,h=null,i=0;i<f;i++){var j=b[i],k=this.inverse_lambda_(j,c);(null===g||k<g)&&(g=k),(null===h||h<k)&&(h=k),k=this.inverse_lambda_(j,d),k<g&&(g=k),h<k&&(h=k);for(var l=1;l<=2;l++){var m=e+Math.PI*l;if(m<c)throw new Error("hoge!");if(d<m)break;k=this.inverse_lambda_(j,m),k<g&&(g=k),h<k&&(h=k)}}if(g<-Math.PI||Math.PI<=g){var n=2*Math.PI*Math.floor((g+Math.PI)/(2*Math.PI));g-=n,h-=n}return[g,h]},ProjTMERC.prototype.inversePhiRange_=function(a,b){var c=a[0]<=a[1]?a[0]:a[1],d=a[0]<=a[1]?a[1]:a[0],e=b[0]<=b[1]?b[0]:b[1],f=b[0]<=b[1]?b[1]:b[0],g=this.inversePhiRangeAtY_([c,d],[e,f]),h=this.inversePhiRangeAtX_([e,f],[c,d]),i=this.mergeRange_(h,g);return i},ProjTMERC.prototype.inversePhiRangeAtY_=function(a,b){for(var c=a[0]<=a[1]?a[0]:a[1],d=a[0]<=a[1]?a[1]:a[0],e=b.length,f=null,g=null,h=0;h<e;h++){var i=b[h],j=this.inverse_phi_(c,i);(null===f||j<f)&&(f=j),(null===g||g<j)&&(g=j),j=this.inverse_phi_(d,i),j<f&&(f=j),g<j&&(g=j),c<0&&0<d&&(j=this.inverse_phi_(0,i),j<f&&(f=j),g<j&&(g=j))}return[f,g]},ProjTMERC.prototype.inversePhiRangeAtX_=function(a,b){for(var c=a[0]<=a[1]?a[0]:a[1],d=a[0]<=a[1]?a[1]:a[0],e=Math.PI*(Math.floor((c+this.phi0)/Math.PI+.5)-.5)-this.phi0,f=b.length,g=null,h=null,i=0;i<f;i++){var j=b[i],k=this.inverse_phi_(j,c);(null===g||k<g)&&(g=k),(null===h||h<k)&&(h=k),k=this.inverse_phi_(j,d),k<g&&(g=k),h<k&&(h=k);for(var l=1;l<=2;l++){var m=e+Math.PI*l;if(m<c)throw new Error("hoge!");if(d<m)break;k=this.inverse_phi_(j,m),k<g&&(g=k),h<k&&(h=k)}}return[g,h]},ProjTMERC.prototype.getVertexShaderStr=function(){return ProjTMERC.VERTEX_SHADER_STR},ProjTMERC.prototype.getFragmentShaderStr=function(){return ProjTMERC.FRAGMENT_SHADER_STR},ProjTMERC.VERTEX_SHADER_STR=["precision highp float;","attribute float aCoordX;","attribute float aCoordY;","uniform mat3 uFwdTransform;","uniform vec2 uProjCenter;","varying vec2 vViewCoord;","uniform float uPointSize;","uniform lowp int uCoordType;","uniform lowp int uTextureType;","const float pi = 3.14159265;","const float epsilon = 0.001;","vec2 proj_forward(vec2 center, vec2 lp)","{","  float b = cos(lp.y) * sin(lp.x - center.x);","  float x = log((1.0 + b) / (1.0 - b)) / 2.0;","  float y = atan(tan(lp.y), cos(lp.x - center.x)) - center.y;","  return vec2(x, y);","}","void main()","{","  vec3 pos;","  if ( uTextureType == 2 || uCoordType == 2 ) {","    pos = vec3(aCoordX, aCoordY, 1.0);","  } else if ( uCoordType == 1 ) {","    pos = uFwdTransform * vec3(aCoordX, aCoordY, 1.0);","  } else {","    vec2 xy = proj_forward(uProjCenter, vec2(aCoordX, aCoordY));","    pos = uFwdTransform * vec3(xy.x, xy.y, 1.0);","  }","  gl_Position = vec4(pos, 1.0);","  gl_PointSize = uPointSize;","}"].join("\n"),ProjTMERC.FRAGMENT_SHADER_STR=["precision highp float;","uniform mat3 uInvTransform;","uniform vec2 uDataCoord1;","uniform vec2 uDataCoord2;","uniform lowp int uCoordType;","uniform lowp int uTextureType;","uniform sampler2D uTexture;","uniform vec2 uProjCenter;","uniform vec4 uColor;","const float pi = 3.14159265;","const float epsilon = 0.00000001;","const float blurRatio = 0.015;","const float xyRadius = pi;","vec2 proj_inverse(vec2 center, vec2 xy)","{","  float d = xy.y + center.y;","  float ep = exp(xy.x);","  float em = exp(-xy.x);","  float ch = (ep + em) / 2.0;","  float sh = (ep - em) / 2.0;","  float phi = asin( clamp( sin(d) / ch, -1.0, 1.0 ) );","  float lam = mod( center.x + atan( sh, cos(d) ) + pi, 2.0 * pi ) - pi;","  return vec2(lam, phi);","}","float inner_xy(vec2 xy)","{","  return 1.0;","}","void main()","{","  vec4 outColor;","  bool isDiscard = false;","  if ( uTextureType == 2 ) {","    float inXY = 1.0;","    vec2 coord;","    if ( uCoordType == 2 ) {","      coord = gl_PointCoord.xy;","    } else {","      vec3 viewCoord = uInvTransform * vec3(gl_PointCoord.x, gl_PointCoord.y, 1.0);","      inXY = inner_xy(viewCoord.xy);","      if ( 0.0 < inXY ) {","        if ( uCoordType == 1 ) {","          coord = viewCoord.xy;","        } else if ( uCoordType == 0 ) {","          coord = proj_inverse(uProjCenter, viewCoord.xy);","        }","      } else {","        isDiscard = true;","        coord = vec2(0.0, 0.0);","      }","    }","    if ( !isDiscard ) {","      vec2 ts = (coord - uDataCoord1) / (uDataCoord2 - uDataCoord1);","      if ( 0.0 <= ts.x && 0.0 <= ts.y && ts.x <= 1.0 && ts.y <= 1.0) {","        outColor = texture2D(uTexture, vec2(ts.x, 1.0 - ts.y)) * inXY;","      } else {","        isDiscard = true;","      }","    }","  } else if ( uTextureType == 1 ) {","    outColor = texture2D(uTexture, gl_PointCoord);","    isDiscard = (outColor.a == 0.0);","  } else {","    outColor = uColor;","    isDiscard = (outColor.a == 0.0);","  }","  if ( isDiscard ) {","    discard;","  } else {","    gl_FragColor = outColor;","  }","}"].join("\n"),"undefined"!=typeof module&&module.exports&&(module.exports=ProjTMERC);