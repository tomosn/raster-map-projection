/*!
 * RasterMapProjection v0.0.29  2019-06-02
 *   https://github.com/tomosn/raster-map-projection
 *   A JavaScript library for on-the-fly map projection of raster tiles using WebGL.
 * Copyright (C) 2016-2019 T.Seno
 * All rights reserved. 
 * @license GPL v3 License (http://www.gnu.org/licenses/gpl.html)
 */

"use strict";if("undefined"!=typeof module&&module.exports)var ProjMath=require("./rasterproj-common.js");function ProjTMERC(e,t){this.lam0=e,this.phi0=t}RasterMapProjection.createProjection=function(e,t,r){return new ProjTMERC(e,t)},ProjTMERC.RANGE_RECTANGLE={x1:-Math.PI,y1:-Math.PI,x2:+Math.PI,y2:+Math.PI},ProjTMERC.prototype.getRange=function(){return Object.assign({},ProjTMERC.RANGE_RECTANGLE)},ProjTMERC.prototype.getProjCenter=function(){return{lambda:this.lam0,phi:this.phi0}},ProjTMERC.prototype.setProjCenter=function(e,t){this.lam0=e,this.phi0=t},ProjTMERC.prototype.checkXYDomain=function(e,t,r){return!0},ProjTMERC.prototype.forward=function(e,t){const r=Math.cos(t)*Math.sin(e-this.lam0),o=Math.log((1+r)/(1-r))/2;let a=Math.atan2(Math.tan(t),Math.cos(e-this.lam0))-this.phi0;return(a<-Math.PI||Math.PI<=a)&&(a-=2*Math.PI*Math.floor((a+Math.PI)/(2*Math.PI))),{x:o,y:a}},ProjTMERC.prototype.inverse=function(e,t){const r=this.inverse_phi_(e,t);let o=this.inverse_lambda_(e,t);return(o<-Math.PI||Math.PI<=o)&&(o-=2*Math.PI*Math.floor((o+Math.PI)/(2*Math.PI))),{lambda:o,phi:r}},ProjTMERC.prototype.inverse_phi_=function(e,t){return Math.asin(ProjMath.clamp(Math.sin(t+this.phi0)/Math.cosh(e),-1,1))},ProjTMERC.prototype.inverse_lambda_=function(e,t){return Math.atan2(Math.sinh(e),Math.cos(t+this.phi0))+this.lam0},ProjTMERC.prototype.inverse_lambda_atY_=function(e,t){const r=Math.cos(t+this.phi0);if(0===r)return 0<=e?Math.PI/2:-Math.PI/2;const o=Math.sinh(e),a=Math.atan2(o,r)+this.lam0;return r<0&&o<0?a+2*Math.PI:a},ProjTMERC.prototype.containsNorthPole_=function(e,t,r,o){if(r<0||0<e)return!1;const a=(2*Math.floor((t+this.phi0)/(2*Math.PI)-.5)+.5)*Math.PI-this.phi0;for(let e=0;e<256;++e){const r=a+2*Math.PI*e;if(o<r)break;if(t<=r&&r<=o)return!0}return!1},ProjTMERC.prototype.containsSouthPole_=function(e,t,r,o){if(r<0||0<e)return!1;const a=(2*Math.floor((t+this.phi0)/(2*Math.PI)+.5)-.5)*Math.PI-this.phi0;for(let e=0;e<256;++e){const r=a+2*Math.PI*e;if(o<r)break;if(t<=r&&r<=o)return!0}return!1},ProjTMERC.prototype.inverseBoundingBox=function(e){const t=e.x1<=e.x2?e.x1:e.x2,r=e.x1<=e.x2?e.x2:e.x1,o=e.y1<=e.y2?e.y1:e.y2,a=e.y1<=e.y2?e.y2:e.y1;if(t<=0&&0<=r){const e=this.containsNorthPole_(t,o,r,a),n=this.containsSouthPole_(t,o,r,a);if(e&&n)return{lambda1:-Math.PI,lambda2:+Math.PI,phi1:-Math.PI/2,phi2:+Math.PI/2};if(e||n){const n=this.inversePhiRange_([t,r],[o,a]);return e?{lambda1:-Math.PI,lambda2:+Math.PI,phi1:n[0],phi2:Math.PI/2}:{lambda1:-Math.PI,lambda2:+Math.PI,phi1:-Math.PI/2,phi2:n[1]}}}const n=this.inversePhiRange_([t,r],[o,a]);let i=this.inverseLambdaRange_([t,r],[o,a]);return i=this.normalizeLambdaRange_(i),2*Math.PI<i[1]-i[0]&&(i=[-Math.PI,Math.PI]),{lambda1:i[0],lambda2:i[1],phi1:n[0],phi2:n[1]}},ProjTMERC.prototype.mergeRange_=function(e,t){let r=null;return null==e?r=t:null!=t&&(r=e,t[0]<r[0]&&(r[0]=t[0]),r[1]<t[1]&&(r[1]=t[1])),r},ProjTMERC.prototype.normalizeLambdaRange_=function(e){const t=e[0];if(-Math.PI<=t&&t<Math.PI)return e;const r=2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI));return[e[0]-r,e[1]-r]},ProjTMERC.prototype.inverseLambdaRange_=function(e,t){const r=e[0]<=e[1]?e[0]:e[1],o=e[0]<=e[1]?e[1]:e[0],a=t[0]<=t[1]?t[0]:t[1],n=t[0]<=t[1]?t[1]:t[0],i=this.inverseLambdaRangeAtY_([r,o],[a,n]),l=this.inverseLambdaRangeAtX_([a,n],[r,o]);return this.mergeRange_(l,i)},ProjTMERC.prototype.inverseLambdaRangeAtY_=function(e,t){const r=e[0]<=e[1]?e[0]:e[1],o=e[0]<=e[1]?e[1]:e[0],a=r<=0&&0<=o,n=t.length;let i=null,l=null;for(let e=0;e<n;e++){const n=t[e];let v=a?this.inverse_lambda_atY_(r,n):this.inverse_lambda_(r,n);(null===i||v<i)&&(i=v),(null===l||l<v)&&(l=v),(v=a?this.inverse_lambda_atY_(o,n):this.inverse_lambda_(o,n))<i&&(i=v),l<v&&(l=v)}if(i<-Math.PI||Math.PI<=i){const e=2*Math.PI*Math.floor((i+Math.PI)/(2*Math.PI));i-=e,l-=e}return[i,l]},ProjTMERC.prototype.inverseLambdaRangeAtX_=function(e,t){const r=e[0]<=e[1]?e[0]:e[1],o=e[0]<=e[1]?e[1]:e[0],a=Math.PI*Math.floor((r+this.phi0)/Math.PI)-this.phi0,n=t.length;let i=null,l=null;for(let e=0;e<n;e++){const n=t[e];let v=this.inverse_lambda_(n,r);(null===i||v<i)&&(i=v),(null===l||l<v)&&(l=v),(v=this.inverse_lambda_(n,o))<i&&(i=v),l<v&&(l=v);for(let e=1;e<=2;e++){const t=a+Math.PI*e;if(o<t)break;(v=this.inverse_lambda_(n,t))<i&&(i=v),l<v&&(l=v)}}if(i<-Math.PI||Math.PI<=i){const e=2*Math.PI*Math.floor((i+Math.PI)/(2*Math.PI));i-=e,l-=e}return[i,l]},ProjTMERC.prototype.inversePhiRange_=function(e,t){const r=e[0]<=e[1]?e[0]:e[1],o=e[0]<=e[1]?e[1]:e[0],a=t[0]<=t[1]?t[0]:t[1],n=t[0]<=t[1]?t[1]:t[0],i=this.inversePhiRangeAtY_([r,o],[a,n]),l=this.inversePhiRangeAtX_([a,n],[r,o]);return this.mergeRange_(l,i)},ProjTMERC.prototype.inversePhiRangeAtY_=function(e,t){const r=e[0]<=e[1]?e[0]:e[1],o=e[0]<=e[1]?e[1]:e[0],a=t.length;let n=null,i=null;for(let e=0;e<a;e++){const a=t[e];let l=this.inverse_phi_(r,a);(null===n||l<n)&&(n=l),(null===i||i<l)&&(i=l),(l=this.inverse_phi_(o,a))<n&&(n=l),i<l&&(i=l),r<0&&0<o&&((l=this.inverse_phi_(0,a))<n&&(n=l),i<l&&(i=l))}return[n,i]},ProjTMERC.prototype.inversePhiRangeAtX_=function(e,t){const r=e[0]<=e[1]?e[0]:e[1],o=e[0]<=e[1]?e[1]:e[0],a=Math.PI*(Math.floor((r+this.phi0)/Math.PI+.5)-.5)-this.phi0,n=t.length;let i=null,l=null;for(let e=0;e<n;e++){const n=t[e];let v=this.inverse_phi_(n,r);(null===i||v<i)&&(i=v),(null===l||l<v)&&(l=v),(v=this.inverse_phi_(n,o))<i&&(i=v),l<v&&(l=v);for(let e=1;e<=2;e++){const t=a+Math.PI*e;if(o<t)break;(v=this.inverse_phi_(n,t))<i&&(i=v),l<v&&(l=v)}}return[i,l]},ProjTMERC.prototype.getVertexShaderStr=function(){return ProjTMERC.VERTEX_SHADER_STR},ProjTMERC.prototype.getFragmentShaderStr=function(){return ProjTMERC.FRAGMENT_SHADER_STR},ProjTMERC.VERTEX_SHADER_STR=["precision highp float;","attribute float aCoordX;","attribute float aCoordY;","uniform mat3 uFwdTransform;","uniform vec2 uProjCenter;","varying vec2 vCoord;","varying float vInRange;","uniform float uPointSize;","uniform lowp int uCoordType;","uniform lowp int uTextureType;","const float pi = 3.141592653589793;","const float epsilon = 0.001;","vec2 proj_forward(vec2 center, vec2 lp) {","  float b = cos(lp.y) * sin(lp.x - center.x);","  float x = log((1.0 + b) / (1.0 - b)) / 2.0;","  float y = atan(tan(lp.y), cos(lp.x - center.x));","  return vec2(x, y - center.y);","}","float check_xy_range(vec2 xy) {","  return step(-pi, xy.x) - step(pi, xy.x);","}","void main() {","  vInRange;","  vec3 pos;","  if ( uTextureType == 2 || uCoordType == 2 ) {","    vInRange = 1.0;","    pos = vec3(aCoordX, aCoordY, 1.0);","  } else if ( uCoordType == 1 ) {","    vInRange = check_xy_range(vec2(aCoordX, aCoordY));","    pos = uFwdTransform * vec3(aCoordX, aCoordY, 1.0);","  } else {","    vec2 xy = proj_forward(uProjCenter, vec2(aCoordX, aCoordY));","    vInRange = check_xy_range(xy);","    pos = uFwdTransform * vec3(xy.x, xy.y, 1.0);","  }","  vCoord = pos.xy;","  gl_Position = vec4(pos, 1.0);","  gl_PointSize = uPointSize;","}"].join("\n"),ProjTMERC.FRAGMENT_SHADER_STR=["precision highp float;","uniform mat3 uInvTransform;","uniform vec2 uDataCoord1;","uniform vec2 uDataCoord2;","uniform vec2 uClipCoord1;","uniform vec2 uClipCoord2;","uniform lowp int uCoordType;","uniform lowp int uTextureType;","uniform vec2 uCanvasSize;","uniform float uGraticuleIntervalDeg;","uniform sampler2D uTexture;","uniform vec2 uProjCenter;","uniform vec4 uColor;","uniform float uOpacity;","varying vec2 vCoord;","varying float vInRange;","const float pi = 3.141592653589793;","const float epsilon = 0.00000001;","const float blurRatio = 0.015;","vec2 proj_inverse(vec2 center, vec2 xy) {","  float d = xy.y + center.y;","  float ep = exp(xy.x);","  float em = exp(-xy.x);","  float ch = (ep + em) / 2.0;","  float sh = (ep - em) / 2.0;","  float phi = asin( clamp( sin(d) / ch, -1.0, 1.0 ) );","  float lam = mod( center.x + atan( sh, cos(d) ) + pi, 2.0 * pi ) - pi;","  return vec2(lam, phi);","}","float inner_xy(vec2 xy) {","  return 1.0;","}","float validate_xy(vec2 xy) {","  return 1.0;","}","vec2 graticule_level(vec2 lp, bool isNearDateLine) {","  vec2 lonlat = degrees(lp);","  if ( isNearDateLine ) {","    lonlat.x = mod(lonlat.x + 360.0, 360.0);","  }","  return floor(lonlat / uGraticuleIntervalDeg);","}","void render_graticule() {","  vec2 viewCoord = (uInvTransform * vec3(vCoord.x, vCoord.y, 1.0)).xy;","  if ( validate_xy(viewCoord) == 0.0 ) {","    discard;","    return;","  }","  vec2 lp = proj_inverse(uProjCenter, viewCoord);","  vec2 baseLonLat = degrees(lp);","  float absLat = abs(baseLonLat.y);","  if (81.0 < absLat) {","    discard;","    return;","  }","  float dx = 0.5 / uCanvasSize.x;","  float dy = 0.5 / uCanvasSize.y;","  vec2 tv = (uInvTransform * vec3(vCoord.x, vCoord.y, 1.0)).xy;","  vec2 tdx = uInvTransform[0].xy * dx;","  vec2 tdy = uInvTransform[1].xy * dy;","  vec2 v01 = tv - 3.0 * tdx + 1.0 * tdy;","  vec2 v02 = tv - 3.0 * tdx - 1.0 * tdy;","  vec2 v10 = tv - 1.0 * tdx + 3.0 * tdy;","  vec2 v11 = tv - 1.0 * tdx + 1.0 * tdy;","  vec2 v12 = tv - 1.0 * tdx - 1.0 * tdy;","  vec2 v13 = tv - 1.0 * tdx - 3.0 * tdy;","  vec2 v20 = tv + 1.0 * tdx + 3.0 * tdy;","  vec2 v21 = tv + 1.0 * tdx + 1.0 * tdy;","  vec2 v22 = tv + 1.0 * tdx - 1.0 * tdy;","  vec2 v23 = tv + 1.0 * tdx - 3.0 * tdy;","  vec2 v31 = tv + 3.0 * tdx + 1.0 * tdy;","  vec2 v32 = tv + 3.0 * tdx - 1.0 * tdy;","  if ( validate_xy(v01) == 0.0 ||  validate_xy(v02) == 0.0 || validate_xy(v31) == 0.0 || validate_xy(v32) == 0.0) {","    discard;","    return;","  }","  if ( validate_xy(v10) == 0.0 ||  validate_xy(v11) == 0.0 || validate_xy(v12) == 0.0 || validate_xy(v13) == 0.0) {","    discard;","    return;","  }","  if ( validate_xy(v20) == 0.0 ||  validate_xy(v21) == 0.0 || validate_xy(v22) == 0.0 || validate_xy(v23) == 0.0) {","    discard;","    return;","  }","  bool isNearDateLine = ( 135.0 < abs(baseLonLat.x) );","  vec2 l01 = graticule_level(proj_inverse(uProjCenter, v01), isNearDateLine);","  vec2 l02 = graticule_level(proj_inverse(uProjCenter, v02), isNearDateLine);","  vec2 l10 = graticule_level(proj_inverse(uProjCenter, v10), isNearDateLine);","  vec2 l11 = graticule_level(proj_inverse(uProjCenter, v11), isNearDateLine);","  vec2 l12 = graticule_level(proj_inverse(uProjCenter, v12), isNearDateLine);","  vec2 l13 = graticule_level(proj_inverse(uProjCenter, v13), isNearDateLine);","  vec2 l20 = graticule_level(proj_inverse(uProjCenter, v20), isNearDateLine);","  vec2 l21 = graticule_level(proj_inverse(uProjCenter, v21), isNearDateLine);","  vec2 l22 = graticule_level(proj_inverse(uProjCenter, v22), isNearDateLine);","  vec2 l23 = graticule_level(proj_inverse(uProjCenter, v23), isNearDateLine);","  vec2 l31 = graticule_level(proj_inverse(uProjCenter, v31), isNearDateLine);","  vec2 l32 = graticule_level(proj_inverse(uProjCenter, v32), isNearDateLine);","  vec2 z11 = -4.0 * l11 + l01 + l10 + l21 + l12;","  vec2 z21 = -4.0 * l21 + l11 + l20 + l31 + l22;","  vec2 z12 = -4.0 * l12 + l02 + l11 + l22 + l13;","  vec2 z22 = -4.0 * l22 + l12 + l21 + l32 + l23;","  vec2 col = (min(abs(z11), 1.0) + min(abs(z21), 1.0) + min(abs(z12), 1.0) + min(abs(z22), 1.0)) * 0.25;","  float alpha = 0.0;","  if (80.0 < absLat) {","    alpha = col.y;","  } else {","    alpha = max(col.x, col.y);","  }","  if (alpha == 0.0) {","    discard;","    return;","  }","  vec3 lineColor = vec3(0.8);","  gl_FragColor = vec4(lineColor, alpha * 0.75);","}","void render_surface_texture() {","  float inXY = 1.0;","  vec2 coord;","  if ( uCoordType == 2 ) {","    coord = vCoord;","  } else if ( uCoordType == 1 ) {","    coord = (uInvTransform * vec3(vCoord.x, vCoord.y, 1.0)).xy;","    inXY = inner_xy(coord);","    if ( inXY <= 0.0 ) {","      discard;","      return;","    }","  } else if ( uCoordType == 0 ) {","    vec2 viewCoord = (uInvTransform * vec3(vCoord.x, vCoord.y, 1.0)).xy;","    inXY = inner_xy(viewCoord);","    if ( inXY <= 0.0 ) {","      discard;","      return;","    }","    coord = proj_inverse(uProjCenter, viewCoord);","  }","  vec2 ts = (coord - uDataCoord1) / (uDataCoord2 - uDataCoord1);","  if ( all(lessThanEqual(uClipCoord1, ts)) && all(lessThanEqual(ts, uClipCoord2)) ) {","    vec4 outColor = texture2D(uTexture, vec2(ts.x, 1.0 - ts.y)) * inXY;","    outColor.a = outColor.a * uOpacity;","    gl_FragColor = outColor;","  } else {","    discard;","  }","}","void render_point_texture() {","  vec4 outColor = texture2D(uTexture, gl_PointCoord);","  if ( outColor.a == 0.0 ) {","    discard;","    return;","  }","  gl_FragColor = outColor;","}","void render_vector() {","  if ( uColor.a == 0.0 ) {","    discard;","    return;","  }","  gl_FragColor = uColor;","}","void main() {","  if ( vInRange < 0.5 ) {","    discard;","    return;","  }","  if ( 0.0 < uGraticuleIntervalDeg ) {","    render_graticule();","    return;","  }","  if ( uTextureType == 2 ) {","    render_surface_texture();","  } else if ( uTextureType == 1 ) {","    render_point_texture();","  } else {","    render_vector();","  }","}"].join("\n"),"undefined"!=typeof module&&module.exports&&(module.exports=ProjTMERC);