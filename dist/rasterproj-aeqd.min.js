/*!
 * RasterMapProjection v0.0.29  2019-06-02
 *   https://github.com/tomosn/raster-map-projection
 *   A JavaScript library for on-the-fly map projection of raster tiles using WebGL.
 * Copyright (C) 2016-2019 T.Seno
 * All rights reserved. 
 * @license GPL v3 License (http://www.gnu.org/licenses/gpl.html)
 */

"use strict";if("undefined"!=typeof module&&module.exports)var RasterProjCommon=require("./rasterproj-common.js"),RasterMapProjection=RasterProjCommon.RasterMapProjection,ProjMath=RasterProjCommon.ProjMath;function ProjDiscreteMath(t){this.divN_=t,this.unit_=Math.PI/t}function ProjAEQD(t,e,r){this.lam0=t,this.phi0=e,this.divN_=void 0!==r?r:180,this.dMath_=new ProjDiscreteMath(this.divN_),this.sin_phi0_=Math.sin(e),this.cos_phi0_=Math.cos(e)}RasterMapProjection.createProjection=function(t,e,r){return new ProjAEQD(t,e,r)},ProjDiscreteMath.prototype.toDiscrete=function(t){return Math.floor(t/this.unit_)},ProjDiscreteMath.prototype.cosR_lower=function(t,e){const r=0<=t?(t+1)*this.unit_:-t*this.unit_,o=Math.sqrt(r*r+e*e);return o<=Math.PI?Math.cos(o):-1},ProjDiscreteMath.prototype.cosR_upper=function(t,e){const r=0<=t?t*this.unit_:(-t-1)*this.unit_,o=Math.sqrt(r*r+e*e);return o<=Math.PI?Math.cos(o):-1},ProjDiscreteMath.prototype.sinR_lower=function(t,e){const r=t*this.unit_,o=(t+1)*this.unit_,i=Math.sqrt(r*r+e*e),a=Math.sqrt(o*o+e*e);if(Math.PI<=i||Math.PI<=a)return 0;if(i<=ProjMath.HALF_PI&&a<=ProjMath.HALF_PI){const t=Math.min(i,a);return Math.sin(t)}if(ProjMath.HALF_PI<=i&&ProjMath.HALF_PI<=a){const t=Math.max(i,a);return Math.sin(t)}const n=Math.sin(i),s=Math.sin(a);return n<s?n:s},ProjDiscreteMath.prototype.sinR_upper=function(t,e){const r=t*this.unit_,o=(t+1)*this.unit_,i=Math.sqrt(r*r+e*e),a=Math.sqrt(o*o+e*e);if(Math.PI<=i&&Math.PI<=a)return 0;if(i<=ProjMath.HALF_PI&&a<=ProjMath.HALF_PI){const t=Math.max(i,a);return Math.sin(t)}if(ProjMath.HALF_PI<=i&&ProjMath.HALF_PI<=a){const t=Math.min(i,a);return Math.sin(t)}return 1},ProjDiscreteMath.prototype.R_cotR_lower=function(t,e){const r=0<=t?(t+1)*this.unit_:-t*this.unit_,o=Math.sqrt(r*r+e*e);return o<ProjMath.EPSILON?1:o<Math.PI?o/Math.tan(o):-1/0},ProjDiscreteMath.prototype.R_cotR_upper=function(t,e){const r=0<=t?t*this.unit_:(-t-1)*this.unit_,o=Math.sqrt(r*r+e*e);return o<ProjMath.EPSILON?1:o<Math.PI?o/Math.tan(o):-1/0},ProjDiscreteMath.prototype.sinR_divR_lower=function(t,e){const r=0<=t?(t+1)*this.unit_:-t*this.unit_,o=Math.sqrt(r*r+e*e);return o<ProjMath.EPSILON?1:o<Math.PI?Math.sin(o)/o:0},ProjDiscreteMath.prototype.sinR_divR_upper=function(t,e){const r=0<=t?t*this.unit_:(-t-1)*this.unit_,o=Math.sqrt(r*r+e*e);return o<ProjMath.EPSILON?1:o<Math.PI?Math.sin(o)/o:0},ProjDiscreteMath.prototype.X_lower=function(t){return t*this.unit_},ProjDiscreteMath.prototype.X_upper=function(t){return(t+1)*this.unit_},ProjAEQD.RANGE_RECTANGLE={x1:-Math.PI,y1:-Math.PI,x2:+Math.PI,y2:+Math.PI},ProjAEQD.prototype.getRange=function(){return Object.assign({},ProjAEQD.RANGE_RECTANGLE)},ProjAEQD.prototype.getProjCenter=function(){return{lambda:this.lam0,phi:this.phi0}},ProjAEQD.prototype.setProjCenter=function(t,e){this.lam0=t,this.phi0=e,this.sin_phi0_=Math.sin(e),this.cos_phi0_=Math.cos(e)},ProjAEQD.prototype.checkXYDomain=function(t,e,r){let o=Math.PI;if(null!=r&&(o*=r),Math.abs(t)<o&&Math.abs(e)<o)return!0;return t*t+e*e<o*o},ProjAEQD.prototype.forward=function(t,e){const r=Math.sin(e),o=Math.cos(e),i=Math.sin(t-this.lam0),a=Math.cos(t-this.lam0),n=Math.acos(this.sin_phi0_*r+this.cos_phi0_*o*a);if(Math.abs(n)<ProjMath.EPSILON)return{x:0,y:0};const s=Math.sin(n);if(Math.abs(s)<ProjMath.EPSILON)return null;const h=n/s;return{x:h*o*i,y:h*(this.cos_phi0_*r-this.sin_phi0_*o*a)}},ProjAEQD.prototype.inverse=function(t,e){const r=t*t+e*e;if(ProjMath.PI_SQ<r)return null;const o=Math.sqrt(r);if(o<ProjMath.EPSILON)return{lambda:this.lam0,phi:this.phi0};const i=o,a=Math.sin(i),n=Math.cos(i),s=n*this.sin_phi0_+e*a*this.cos_phi0_/o,h=Math.asin(ProjMath.clamp(s,-1,1));let c;return((c=ProjMath.HALF_PI-ProjMath.EPSILON<this.phi0?Math.atan2(t,-e)+this.lam0:this.phi0<-(ProjMath.HALF_PI-ProjMath.EPSILON)?Math.atan2(t,e)+this.lam0:Math.atan2(t*a,o*n*this.cos_phi0_-e*this.sin_phi0_*a)+this.lam0)<-Math.PI||Math.PI<=c)&&(c-=2*Math.PI*Math.floor((c+Math.PI)/(2*Math.PI))),{lambda:c,phi:h}},ProjAEQD.prototype.inverseBoundingBox=function(t){const e=t.x1<=t.x2?t.x1:t.x2,r=t.x1<=t.x2?t.x2:t.x1,o=t.y1<=t.y2?t.y1:t.y2,i=t.y1<=t.y2?t.y2:t.y1;if(e<=0&&0<=r){const t=ProjMath.HALF_PI-this.phi0,a=-(ProjMath.HALF_PI-ProjMath.EPSILON)<this.phi0&&o<=t&&t<=i,n=-ProjMath.HALF_PI-this.phi0,s=this.phi0<ProjMath.HALF_PI-ProjMath.EPSILON&&o<=n&&n<=i;if(a&&s)return{lambda1:-Math.PI,lambda2:+Math.PI,phi1:-Math.PI/2,phi2:+Math.PI/2};if(a||s){const t=this.inversePhiRange_([e,r],[o,i]);return a?{lambda1:-Math.PI,lambda2:+Math.PI,phi1:t[0],phi2:Math.PI/2}:{lambda1:-Math.PI,lambda2:+Math.PI,phi1:-Math.PI/2,phi2:t[1]}}if(i<n||t<o){const t=this.inverseLambdaRangeAtY_([e,-ProjMath.EPSILON],[o,i]),a=this.inverseLambdaRangeAtX_([o,i],[e]),n=this.inverseLambdaRangeAtY_([ProjMath.EPSILON,r],[o,i]),s=this.inverseLambdaRangeAtX_([o,i],[r]),h=this.mergeRange_(t,a);let c=[this.mergeRange_(n,s)[0],h[1]+2*Math.PI];const l=this.inversePhiRange_([e,r],[o,i]);return{lambda1:(c=this.normalizeLambdaRange_(c))[0],lambda2:c[1],phi1:l[0],phi2:l[1]}}}const a=this.inversePhiRange_([e,r],[o,i]);let n=this.inverseLambdaRange_([e,r],[o,i]);return{lambda1:(n=this.normalizeLambdaRange_(n))[0],lambda2:n[1],phi1:a[0],phi2:a[1]}},ProjAEQD.prototype.mergeRange_=function(t,e){let r=null;return null==t?r=e:null!=e&&(r=t,e[0]<r[0]&&(r[0]=e[0]),r[1]<e[1]&&(r[1]=e[1])),r},ProjAEQD.prototype.normalizeLambdaRange_=function(t){const e=t[0];if(-Math.PI<=e&&e<Math.PI)return t;const r=2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI));return[t[0]-r,t[1]-r]},ProjAEQD.prototype.inverseLambdaRange_=function(t,e){const r=t[0]<=t[1]?t[0]:t[1],o=t[0]<=t[1]?t[1]:t[0],i=e[0]<=e[1]?e[0]:e[1],a=e[0]<=e[1]?e[1]:e[0],n=this.inverseLambdaRangeAtY_([r,o],[i,a]),s=this.inverseLambdaRangeAtX_([i,a],[r,o]);return this.mergeRange_(s,n)},ProjAEQD.prototype.inverseLambdaRangeAtY_=function(t,e){const r=t[0]<=t[1]?t[0]:t[1],o=t[0]<=t[1]?t[1]:t[0];let i=null;const a=this.dMath_.toDiscrete(r),n=this.dMath_.toDiscrete(o),s=e.length;for(let t=a;t<=n;++t)for(let r=0;r<s;++r){const o=this.inverseLambdaAtY_(t,e[r]);i=this.mergeRange_(i,o)}return i},ProjAEQD.prototype.inverseLambdaRangeAtX_=function(t,e){const r=t[0]<=t[1]?t[0]:t[1],o=t[0]<=t[1]?t[1]:t[0];let i=null;const a=this.dMath_.toDiscrete(r),n=this.dMath_.toDiscrete(o),s=e.length;for(let t=a;t<=n;++t)for(let r=0;r<s;++r){const o=this.inverseLambdaAtX_(t,e[r]);i=this.mergeRange_(i,o)}return i},ProjAEQD.prototype.inversePhiRange_=function(t,e){const r=t[0]<=t[1]?t[0]:t[1],o=t[0]<=t[1]?t[1]:t[0],i=e[0]<=e[1]?e[0]:e[1],a=e[0]<=e[1]?e[1]:e[0],n=this.inversePhiRangeAtY_([r,o],[i,a]),s=this.inversePhiRangeAtX_([i,a],[r,o]);return this.mergeRange_(s,n)},ProjAEQD.prototype.inversePhiRangeAtY_=function(t,e){const r=t[0]<=t[1]?t[0]:t[1],o=t[0]<=t[1]?t[1]:t[0];let i=null;const a=this.dMath_.toDiscrete(r),n=this.dMath_.toDiscrete(o),s=e.length;for(let t=a;t<=n;++t)for(let r=0;r<s;++r){const o=this.inversePhiAtY_(t,e[r]);i=this.mergeRange_(i,o)}return i},ProjAEQD.prototype.inversePhiRangeAtX_=function(t,e){const r=t[0]<=t[1]?t[0]:t[1],o=t[0]<=t[1]?t[1]:t[0];let i=null;const a=this.dMath_.toDiscrete(r),n=this.dMath_.toDiscrete(o),s=e.length;for(let t=a;t<=n;++t)for(let r=0;r<s;++r){const o=this.inversePhiAtX_(t,e[r]);i=this.mergeRange_(i,o)}return i},ProjAEQD.prototype.inverseLambdaAtX_=function(t,e){if(ProjMath.HALF_PI-ProjMath.EPSILON<Math.abs(this.phi0)){const r=0<this.phi0?-1:1,o=r*this.dMath_.X_lower(t),i=r*this.dMath_.X_upper(t),a=o<=i?i:o,n=o<=i?o:i,s=ProjMath.atan2Range({min:e,max:e},{min:n,max:a});return[s.min+this.lam0,s.max+this.lam0]}const r=this.cos_phi0_*this.dMath_.R_cotR_lower(t,e),o=this.cos_phi0_*this.dMath_.R_cotR_upper(t,e),i=r<=o?o:r,a=r<=o?r:o,n=-this.sin_phi0_*this.dMath_.X_lower(t),s=-this.sin_phi0_*this.dMath_.X_upper(t),h=i+(n<=s?s:n),c=a+(n<=s?n:s),l=ProjMath.atan2Range({min:e,max:e},{min:c,max:h});return[l.min+this.lam0,l.max+this.lam0]},ProjAEQD.prototype.inverseLambdaAtY_=function(t,e){if(ProjMath.HALF_PI-ProjMath.EPSILON<Math.abs(this.phi0)){const r=0<this.phi0?-1:1,o=this.dMath_.X_lower(t),i=this.dMath_.X_upper(t),a=ProjMath.atan2Range({min:o,max:i},{min:r*e,max:r*e});return[a.min+this.lam0,a.max+this.lam0]}const r=this.cos_phi0_*this.dMath_.R_cotR_lower(t,e)-this.sin_phi0_*e,o=this.cos_phi0_*this.dMath_.R_cotR_upper(t,e)-this.sin_phi0_*e,i=o<=r?r:o,a=o<=r?o:r,n=this.dMath_.X_lower(t),s=this.dMath_.X_upper(t),h=ProjMath.atan2Range({min:n,max:s},{min:a,max:i});return[h.min+this.lam0,h.max+this.lam0]},ProjAEQD.prototype.inversePhiAtY_=function(t,e){const r=this.dMath_.cosR_lower(t,e)*this.sin_phi0_,o=this.dMath_.cosR_upper(t,e)*this.sin_phi0_,i=r<=o?o:r,a=r<=o?r:o,n=e*this.dMath_.sinR_divR_lower(t,e)*this.cos_phi0_,s=e*this.dMath_.sinR_divR_upper(t,e)*this.cos_phi0_,h=n<=s?s:n,c=n<=s?n:s,l=ProjMath.clamp(i+h,-1,1),_=ProjMath.clamp(a+c,-1,1);return[Math.asin(_),Math.asin(l)]},ProjAEQD.prototype.inversePhiAtX_=function(t,e){const r=this.dMath_.cosR_lower(t,e)*this.sin_phi0_,o=this.dMath_.cosR_upper(t,e)*this.sin_phi0_,i=r<=o?o:r,a=r<=o?r:o,n=Math.abs(this.dMath_.X_lower(t)),s=Math.abs(this.dMath_.X_upper(t)),h=n<=s?s:n,c=n<=s?n:s,l=Math.abs(this.cos_phi0_),_=h*this.dMath_.sinR_divR_upper(t,e)*l,u=c*this.dMath_.sinR_divR_lower(t,e)*l,v=0<=t*this.cos_phi0_?1:-1,p=0<v?+_:-u,d=0<v?+u:-_,P=ProjMath.clamp(i+p,-1,1),M=ProjMath.clamp(a+d,-1,1);return[Math.asin(M),Math.asin(P)]},ProjAEQD.prototype.getVertexShaderStr=function(){return ProjAEQD.VERTEX_SHADER_STR},ProjAEQD.prototype.getFragmentShaderStr=function(){return ProjAEQD.FRAGMENT_SHADER_STR},ProjAEQD.VERTEX_SHADER_STR=["precision highp float;","attribute float aCoordX;","attribute float aCoordY;","uniform mat3 uFwdTransform;","uniform vec2 uProjCenter;","varying vec2 vCoord;","varying float vInRange;","uniform float uPointSize;","uniform lowp int uCoordType;","uniform lowp int uTextureType;","const float pi = 3.141592653589793;","const float epsilon = 0.001;","vec2 proj_forward(vec2 center, vec2 lp) {","  float sinPhi0 = sin(center.y);","  float cosPhi0 = cos(center.y);","  float sinPhi = sin(lp.y);","  float cosPhi = cos(lp.y);","  float sinLam = sin(lp.x - center.x);","  float cosLam = cos(lp.x - center.x);","  float v = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosLam;","  float x = cosPhi * sinLam;","  float y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosLam;","  float k;","  if ( v < -1.0 + epsilon ) {","    return pi * normalize(vec2(x, y));","  }","  float c = acos(v);","  if ( abs(c) < epsilon ) {","    k = 1.0;","  } else {","    k = c / sin(c);","  }","  return k * vec2(x, y);","}","const float xyDomain = 0.94 * pi;","float check_xy_range(vec2 xy) {","  return 1.0 - step(xyDomain, length(xy));","}","void main() {","  vInRange;","  vec3 pos;","  if ( uTextureType == 2 || uCoordType == 2 ) {","    vInRange = 1.0;","    pos = vec3(aCoordX, aCoordY, 1.0);","  } else if ( uCoordType == 1 ) {","    vInRange = check_xy_range(vec2(aCoordX, aCoordY));","    pos = uFwdTransform * vec3(aCoordX, aCoordY, 1.0);","  } else {","    vec2 xy = proj_forward(uProjCenter, vec2(aCoordX, aCoordY));","    vInRange = check_xy_range(xy);","    pos = uFwdTransform * vec3(xy.x, xy.y, 1.0);","  }","  vCoord = pos.xy;","  gl_Position = vec4(pos, 1.0);","  gl_PointSize = uPointSize;","}"].join("\n"),ProjAEQD.FRAGMENT_SHADER_STR=["precision highp float;","uniform mat3 uInvTransform;","uniform vec2 uDataCoord1;","uniform vec2 uDataCoord2;","uniform vec2 uClipCoord1;","uniform vec2 uClipCoord2;","uniform lowp int uCoordType;","uniform lowp int uTextureType;","uniform vec2 uCanvasSize;","uniform float uGraticuleIntervalDeg;","uniform sampler2D uTexture;","uniform vec2 uProjCenter;","uniform vec4 uColor;","uniform float uOpacity;","varying vec2 vCoord;","varying float vInRange;","const float pi = 3.141592653589793;","const float epsilon = 0.00000001;","const float blurRatio = 0.015;","vec2 proj_inverse(vec2 center, vec2 xy) {","  float xyRadius = pi;","  float sinPhi0 = sin(center.y);","  float cosPhi0 = cos(center.y);","  float rho = length(xy);","  if ( rho < epsilon ) {","    return center;","  }","  if ( rho - epsilon > xyRadius ) {","    rho = xyRadius;","  }","  float c_rh = rho;","  float cos_c = cos(c_rh);","  float sin_c = sin(c_rh);","  float phi = asin( clamp( cos_c * sinPhi0 + xy.y * sin_c * cosPhi0 / rho, -1.0, 1.0 ) );","  float lam = mod( center.x + atan( xy.x * sin_c, rho * cosPhi0 * cos_c - xy.y * sinPhi0 * sin_c ) + pi, 2.0 * pi ) - pi;","  return vec2(lam, phi);","}","float inner_xy(vec2 xy) {","  float xyRadius = pi;","  return 1.0 - smoothstep( (1.0 - blurRatio) * xyRadius, (1.0 + blurRatio) * xyRadius, length(xy) );","}","float validate_xy(vec2 xy) {","  float xyRadius = pi;","  return 1.0 - step(xyRadius, length(xy));","}","vec2 graticule_level(vec2 lp, bool isNearDateLine) {","  vec2 lonlat = degrees(lp);","  if ( isNearDateLine ) {","    lonlat.x = mod(lonlat.x + 360.0, 360.0);","  }","  return floor(lonlat / uGraticuleIntervalDeg);","}","void render_graticule() {","  vec2 viewCoord = (uInvTransform * vec3(vCoord.x, vCoord.y, 1.0)).xy;","  if ( validate_xy(viewCoord) == 0.0 ) {","    discard;","    return;","  }","  vec2 lp = proj_inverse(uProjCenter, viewCoord);","  vec2 baseLonLat = degrees(lp);","  float absLat = abs(baseLonLat.y);","  if (81.0 < absLat) {","    discard;","    return;","  }","  float dx = 0.5 / uCanvasSize.x;","  float dy = 0.5 / uCanvasSize.y;","  vec2 tv = (uInvTransform * vec3(vCoord.x, vCoord.y, 1.0)).xy;","  vec2 tdx = uInvTransform[0].xy * dx;","  vec2 tdy = uInvTransform[1].xy * dy;","  vec2 v01 = tv - 3.0 * tdx + 1.0 * tdy;","  vec2 v02 = tv - 3.0 * tdx - 1.0 * tdy;","  vec2 v10 = tv - 1.0 * tdx + 3.0 * tdy;","  vec2 v11 = tv - 1.0 * tdx + 1.0 * tdy;","  vec2 v12 = tv - 1.0 * tdx - 1.0 * tdy;","  vec2 v13 = tv - 1.0 * tdx - 3.0 * tdy;","  vec2 v20 = tv + 1.0 * tdx + 3.0 * tdy;","  vec2 v21 = tv + 1.0 * tdx + 1.0 * tdy;","  vec2 v22 = tv + 1.0 * tdx - 1.0 * tdy;","  vec2 v23 = tv + 1.0 * tdx - 3.0 * tdy;","  vec2 v31 = tv + 3.0 * tdx + 1.0 * tdy;","  vec2 v32 = tv + 3.0 * tdx - 1.0 * tdy;","  if ( validate_xy(v01) == 0.0 ||  validate_xy(v02) == 0.0 || validate_xy(v31) == 0.0 || validate_xy(v32) == 0.0) {","    discard;","    return;","  }","  if ( validate_xy(v10) == 0.0 ||  validate_xy(v11) == 0.0 || validate_xy(v12) == 0.0 || validate_xy(v13) == 0.0) {","    discard;","    return;","  }","  if ( validate_xy(v20) == 0.0 ||  validate_xy(v21) == 0.0 || validate_xy(v22) == 0.0 || validate_xy(v23) == 0.0) {","    discard;","    return;","  }","  bool isNearDateLine = ( 135.0 < abs(baseLonLat.x) );","  vec2 l01 = graticule_level(proj_inverse(uProjCenter, v01), isNearDateLine);","  vec2 l02 = graticule_level(proj_inverse(uProjCenter, v02), isNearDateLine);","  vec2 l10 = graticule_level(proj_inverse(uProjCenter, v10), isNearDateLine);","  vec2 l11 = graticule_level(proj_inverse(uProjCenter, v11), isNearDateLine);","  vec2 l12 = graticule_level(proj_inverse(uProjCenter, v12), isNearDateLine);","  vec2 l13 = graticule_level(proj_inverse(uProjCenter, v13), isNearDateLine);","  vec2 l20 = graticule_level(proj_inverse(uProjCenter, v20), isNearDateLine);","  vec2 l21 = graticule_level(proj_inverse(uProjCenter, v21), isNearDateLine);","  vec2 l22 = graticule_level(proj_inverse(uProjCenter, v22), isNearDateLine);","  vec2 l23 = graticule_level(proj_inverse(uProjCenter, v23), isNearDateLine);","  vec2 l31 = graticule_level(proj_inverse(uProjCenter, v31), isNearDateLine);","  vec2 l32 = graticule_level(proj_inverse(uProjCenter, v32), isNearDateLine);","  vec2 z11 = -4.0 * l11 + l01 + l10 + l21 + l12;","  vec2 z21 = -4.0 * l21 + l11 + l20 + l31 + l22;","  vec2 z12 = -4.0 * l12 + l02 + l11 + l22 + l13;","  vec2 z22 = -4.0 * l22 + l12 + l21 + l32 + l23;","  vec2 col = (min(abs(z11), 1.0) + min(abs(z21), 1.0) + min(abs(z12), 1.0) + min(abs(z22), 1.0)) * 0.25;","  float alpha = 0.0;","  if (80.0 < absLat) {","    alpha = col.y;","  } else {","    alpha = max(col.x, col.y);","  }","  if (alpha == 0.0) {","    discard;","    return;","  }","  vec3 lineColor = vec3(0.8);","  gl_FragColor = vec4(lineColor, alpha * 0.75);","}","void render_surface_texture() {","  float inXY = 1.0;","  vec2 coord;","  if ( uCoordType == 2 ) {","    coord = vCoord;","  } else if ( uCoordType == 1 ) {","    coord = (uInvTransform * vec3(vCoord.x, vCoord.y, 1.0)).xy;","    inXY = inner_xy(coord);","    if ( inXY <= 0.0 ) {","      discard;","      return;","    }","  } else if ( uCoordType == 0 ) {","    vec2 viewCoord = (uInvTransform * vec3(vCoord.x, vCoord.y, 1.0)).xy;","    inXY = inner_xy(viewCoord);","    if ( inXY <= 0.0 ) {","      discard;","      return;","    }","    coord = proj_inverse(uProjCenter, viewCoord);","  }","  vec2 ts = (coord - uDataCoord1) / (uDataCoord2 - uDataCoord1);","  if ( all(lessThanEqual(uClipCoord1, ts)) && all(lessThanEqual(ts, uClipCoord2)) ) {","    vec4 outColor = texture2D(uTexture, vec2(ts.x, 1.0 - ts.y)) * inXY;","    outColor.a = outColor.a * uOpacity;","    gl_FragColor = outColor;","  } else {","    discard;","  }","}","void render_point_texture() {","  vec4 outColor = texture2D(uTexture, gl_PointCoord);","  if ( outColor.a == 0.0 ) {","    discard;","    return;","  }","  gl_FragColor = outColor;","}","void render_vector() {","  if ( uColor.a == 0.0 ) {","    discard;","    return;","  }","  gl_FragColor = uColor;","}","void main() {","  if ( vInRange < 0.5 ) {","    discard;","    return;","  }","  if ( 0.0 < uGraticuleIntervalDeg ) {","    render_graticule();","    return;","  }","  if ( uTextureType == 2 ) {","    render_surface_texture();","  } else if ( uTextureType == 1 ) {","    render_point_texture();","  } else {","    render_vector();","  }","}"].join("\n"),"undefined"!=typeof module&&module.exports&&(module.exports={RasterMapProjection:RasterMapProjection,ProjAEQD:ProjAEQD,ProjDiscreteMath:ProjDiscreteMath});